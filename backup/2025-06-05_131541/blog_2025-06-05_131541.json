[{"blogPK":{"topicName":"datatype","subTopicName":"datatype"},"content":"#### Java is a statically typed programming language. That is, it checks the data types of all values at compile time,# Data type- Defined in terms of `3` components  - `A set of values`,  - A set of `operations` that can be applied,  - A data `representation`, which determines how the values are stored,## Built-in data types- `Predefined data types`,- Ex: `int`, `double`, `String` etc,## Primitive data type- Consists of an `atomic`, `indivisible value`, - Defined without the help of any other data types,- Programmers `can't extend` primitive data types,## Identifier- `Sequence of characters` of unlimited length,- Includes `letters` and `digits`,- First letter must be a letter,- `Spaces` aren't allowed in an identifier,- `Case sensitive`, - Ex: `value`, `VALUE` are different identifier,## Variables- These `memory locations`,- A variable has `3` properties:  - A `memory location` for storing the value,  - The `type of the data` to store at the memory location, and   - A `name` (also called identifier) to refer to the memory location,- Ex: `int sum;` where  - memory for storing `int` is allocated,  - `data type` = `int`,   - `name` = `sum`,## Java supports 2 kinds of data types:- ### Primitive  - Holds `a value`,  - Ex: `int result;`,  - 2 categories:    - Numeric: `byte, short, int, long, char, float, double`,     - Boolean: `boolean`,- ### Reference:   - Holds a `reference to an object`,  - Ex: `String s;`     - Space is allocated for `variable` not for object,  - Ex: `String s = new String(\"Saeed\");`,     - `Space` is allocated separately for `variable` and the `object` it is referring,  - Be alert while modifying object of reference type inside method,    ```java    private static void printHumanData(Human human){      System.out.println(human.getName()+\" -> \"+human.getAge());      human.setAge(26); // will modify main object    }    ```    Using like this:    ```java    Human human = new Human(\"Saeed\",21);    printHumanData(human); // Saeed -> 21    System.out.println(human.getAge()); // 26    ```    - These are discussed briefly in `Classes and Object` section,<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"None\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/operator/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"datatype","subTopicName":"datatype","topic":{"topic_name":"datatype","no_of_sub_topics":1,"folder_name":"datatype","serial":0},"serial":0}},{"blogPK":{"topicName":"operator","subTopicName":"operator"},"content":"# Operator## Introduction- A symbol that performs a specific kind of operation on one, two, or three operands, and produces a result,- Operator based on the number of operands they operate on  - unary: `a++;`,  - binary: `a = b;`,  - ternary: `mx = a > b `?` a `:` b;`,- Operator has `precedence` just like other languages,## Assignment operator(`=`):- `Compile time error` will be shown if right side is not assignment compatible to left side. Ex:  ```java  float f = 1.19F;  int i = 15;  i = f; // compile time error.  i = (int)f; // ok  ```- `num = 25;`  - Assigns 25 to `num`,  - `num = 25` produces 25. So `num1 = num2 = 25` is valid  - `num = 25` is called an expression (no semicolon),  - `num = 25;` is called a statement.- `Declaration`, `Initialization`, `Assignment`  ```java  int count; // Declaration  count = 0; // assignment  int value = 5; // initialization  ```  ## Data type of expression - Type of the result of `b @ c` is evaluated as,  - `double > float > long > int`. It means that,  - Suppose `c` is of double and `b` is of long, then `b @ c` will be double. Got it?- Ex:  ```java  byte b1;  b1 = 5; // ok --------------------(a)  ```  But,  ```java  byte b1;  byte b2 = 2; // ok  byte b3 = 3; // ok  b1 = b2 + b3; // error -----------(b)  b1 = 2 + 3; // ok    -------------(c)  ```  - `(a)` is ok, because `5` is a constant which is within the `-128 to 127`,  - `(b)` is giving error, because `b2+b3` evaluate to `int` and `int` can't be assigned to a `byte` directly,  - `(b)` follows data type of expression,  - `(c)` is ok because `2`,`3` are `compiled time constant` and  `2+3` is calculated at compile time and works like `b1=5`.  ## Division(`/`) and Modulus(`%`)- like `C` or `C++`## Unary plus(`+`) and Unary minus(`-`):- Ex:  ```java  byte b1 = 10;  byte b2 = +5;  b1 = b2; // Ok. byte to byte assignment  b1 = +b2 // error. bcause +b2 convert it into int. Remember Expression data type  ```- Unary minus(`-`) is same like Unary plus(`+`),## Compound assignment operator:- `+=`,`-+`,`*=`, `/=`, `%=` ,- These operators are `faster` and `efficient`,## Increment operator - `++a` :   - First incremented, then   - Other operation,- `a++` :  - Other one operation, then   - increment, then  - others operation,- Ex-1:  ```java  int i = 100;  int j = ++i + 15;  ```  `i = 101`, `j = 116`. Remember `pre increment` is incremented first,- Ex-2:   ```java  int i = 100;  int j = i++ + 15;  ```  Steps be like:  ```  j = 100 + 15; // i = 100  j = 100 + 15; // i = 101  j = 115; // i = 101  ```- Ex-3:  ```java  int i = 15;  i = i++;  ```  Steps be like:  ```  i = 15; // i = 15  i = 15; // i = 16  i = 15; // ans  ```## Decrement: - `--a`, `a--`- Similar to increment rules.## Relational operators- `==`,`!=`, `>`, `>=`, `<`, `<=`,- These are `binary` operator,- For `primitive` operands, it returns true if the both operands represent the `same value`,- For `reference` operands, it returns true if the both operands `refer to the same object` in memory,- Alert while using these operators with reference type,- Ex:  ```java  Kuetian st1 = new Kuetian(75,\"CSE\",\"Pantho\");  Kuetian st2 = new Kuetian(57,\"CSE\",\"Saeed\");  Kuetian st3 = new Kuetian(57,\"CSE\",\"Saeed\");    System.out.println(st1 == st2); // false, because referring different object    System.out.println(st2 == st3); // false, because referring different object    st1 = st3;  System.out.println(st1==st3); // true, since same object  ```- Let's get confused a little  ```java  Integer num1 = 100;  Integer num2 = 100;  System.out.println(num1==num2); // true    Integer num3 = 10000;  Integer num4 = 10000;  System.out.println(num3==num4); // false  ```  Just remember this `num1`,`num2`, `num3`, `num4` are object of class `Integer`. Rest will be discussed later in different section.- So, for reference data type, always use `obj1.equlas(obj2)` instead of `==`.  ```  Integer num3 = 10000;  Integer num4 = 10000;  System.out.println(num3.equals(num4)); // true  ```## Logical operators- Logical AND Operator (`&`),- Short-Circuit AND Operator (`&&`),- Logical OR Operator (`|`),- Logical Short-Circuit OR Operator (`||`),- Logical XOR Operator (`^`),- Compound Boolean Logical Assignment Operators: `&=`, `|=`, `^=`- `Logical` and `short circuit` operator do same thing, only difference is short-circuit operator doesn't execute other condition if not needed,- Ex:  ```java  int i = 24;  int j = 48;  int k = 57;    int count = 0;  boolean outputFromLogical = (i<48) || (j == 48 ) || (++count < 1000); --------(a)  System.out.println(outputFromLogical + \" -> \" + count); // true -> 0       boolean outputFromShortCircuit = (i<48) | (j == 48 ) | (++count < 1000); -----(b)  System.out.println(outputFromShortCircuit + \" -> \" + count); // true -> 1    boolean outputAnd = (i == j) && (i++ ==k); --------(c)  System.out.println(outputAnd+\" \"+i); // false 24    boolean outputShortAnd = (i == j) & (i++ ==k); ----(d)  System.out.println(outputShortAnd+\" \"+i); // false 25  ```  - For `(a)`, it is not needed to check `2nd` and `3rd` condition. Because `1st` is `true`, output will be true since `OR` operation,  - For `(b)`, it will execute all conditions, surely. so count increases here,  - Same for `(c)` & `(d)`,### Ternary Operator (`? :`)- Ex:  ```java  // boolean-expression ? true-expression : false-expression  int a = 5;  int b = 55;  int mx = a>b ? a : b;  ```- Try to avoid this operator,## Operator precedence- Write code in such a way that, precedence doesn't affect calculation,- Operators are:  - `++`,  - `--`,  - `+, -`,  - `~ Bitwise complement`,  - `!`,  - `(type) Cast`,  - `*, /, %`,  - `+, -`,  - `+ String concatenation`,  - `<< Left shift`,  - `>> Signed right shift`,  - `>>> Unsigned right shift`,  - `<`,  - `<=`,  - `>`,  - `>=`,  - `instanceof Type comparison`,  - `==`,  - `!=`,  - `& Bitwise AND`,  - `& Logical AND`,  - `^ Bitwise XOR`,  - `^ Logical XOR`,  - `| Bitwise OR`,  - `| Logical OR`,  - `&& Logical short-circuit AND`,  - `|| Logical short-circuit OR`,  - `?:`,  - `= Assignment`,  - (`+=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, |=,^=`),## Bitwise operators:- Perform operation on `bit level`. Works with only `integers`,- Operators are:  - `& Bitwise AND`,  - `| Bitwise OR` ,  - `^ Bitwise XOR`,  - `~ Bitwise complement (1’s complement)`,  - `<< Left shift`,  - `>> Signed right shift`,  - `>>> Unsigned right shift`,   - `&=, !=, ^=, <<=, >>=, >>>= Compound assignment`,### Java does not let developers overload operators in programs<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datatype/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/classesandobject/part1/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"operator","subTopicName":"operator","topic":{"topic_name":"operator","no_of_sub_topics":1,"folder_name":"operator","serial":1},"serial":0}},{"blogPK":{"topicName":"classesandobject","subTopicName":"classesandobject"},"content":"# Classes and Object - part1## class- Basic unit of Object-Oriented Programming paradigm(pattern),- Ex: `Animal` is a class and `tiger` is an object of `Animal` class,## Structure of JAVA class```java<<modifiers>> class <<class name>> {    // Body of the class goes here}```- Modifiers:  - `Keywords` that associate `special meanings` to the class declaration,  - May have `zero or more modifiers`,- Class name:  - `User defined` class name,  - Follows `Pascal Case` naming convention,- Body of the class:  - Contains `fields`, `methods`,- Ex: (`Hooman.java`)  ```java  public class Hooman {    // ...  }  ```  - has `public` modifier,  - class name is `Hooman`,  - body contains `field`,`constructor` & some `methods`,## Components of java class- A class in Java may consist of `5` components:- ### Field / variables  - Represent properties or `attributes` of objects of that class,  - `2` types of `fields` for a class:    - #### Instance variables:       - `Non-static` variables,      - Every object contains `separate copy` of these variables,      - Must be `accessed using object` of the class,      - Can be accessed using dot(`.`),      - Ex: `obj.name;`,    - #### Class variables:      - `Static` variables,      - Declared using the `static keyword` as a modifier,      - Every object uses `same copy` of these variables,      - `Shared among all objects` of this class,      - Can be `called using class name`,      - Can be accessed using dot(`.`) on both `object` and `class`,      - Ex: `MyClass.count`,  - `static` as well as `non-static` fields are initialized to a default value,    - A `numeric` field (`int`, `long`, ...) is initialized to `zero(0)`,    - A `boolean` field is initialized to `false`,    - A `reference` type field is initialized to `null`,- ### Method  - Represent `behavior of objects` of the class,  - More info is discussed below,- ### Constructor  - Used to `create objects` of the class,  - More info is discussed below,- ### Static initializer  - For `initializing static variables` which need some `calculation`,- ### Instance initializer,  - For `initializing variables` which need some `calculation`,## Understanding components- `this` refers to `current instance`. More details is discussed next section,- See `Hooman.java`,  ```java  public class Hooman {      // Field - 2 Class variables      public static final String SPECIES;      private static int objectCounter = 0;        // Field - 3 instance variables      private String name;      private int age;      private boolean isAdult;        //static initializers - 1      static {          // normally more calculation is performed as per need          SPECIES = \"Homo Sapiens\";      }        //instance initializers - 1      {          isAdult = false; // by default false though      }        //constructor - 1      public Hooman() {          objectCounter++;      }      //constructor - 2      public Hooman(String name, int age) {          this.name = name;          this.age = age;          isAdult = age >= 18;          objectCounter++;      }        // methods - 6 methods      public String getName() {...}      public void setName(String name) {...}      public int getAge() {...}      ...  }  ```## Method again- Represent `behavior` of objects of the class,- Is a named `block of code`,- Structure:  ```java  <<modifiers>> <<return type>> <<method name>> (<<parameters list>>) <<throws clause>> {    // Body of the method goes here  }  ```- `Formal parameters` of a method are treated as local variables,- `throws` is optional,- Ex:  ```java  public void setAge(int age) {     if(age < 0 || age < this.age) return;     this.age = age;     isAdult = (age>=18);  }  ```- `return-type` can be any data type,- `void` means doesn't return any value,- Follows `camelCase` naming convention,- Method signature:  - Combination of     - method `name`, and    - its parameters       - `number`,       - `types`,      - `order`,  - `Modifiers`, `return-type`, and `parameter names` aren't part of the `signature`,  - Ex:    ```java     public int add(int num1, int num2){        return num1+num2;     }    ```    - Signature is: `add(int, int)`;- Not allowed to have more than one method in a class with the same signature,- A class can have `two types of method` like variables:  - `Instant method` and   - `Class method`,## Instance Method- `Non-static` method,- Used to implement `behavior of the objects` of the class,- Must be `called using object`,- Ex: See `showSpecificCharacter()` in `Hooman.java`,  ```java  public void showSpecificCharacter(){      System.out.println(\"Name is => \"+name);  }  ```  Accessing like this  ```java  Hooman anik = new Hooman(\"Anik\",22);  anik.showSpecificCharacter(); // Name is => Anik  ```## Class Method- `static` method,- Used to implement the `behavior of the class` itself,- Can be called using both `object` or `Class name`(Recommended) itself,- Can't access instant variables here, guess why?- Ex: See `showSomeCharacter()` in `Hooman.java`,  ```java  public static void showSomeCharacter(){    System.out.println(\"General characteristics\");    //System.out.println(name);//can't access instant variable here  }  ```  Calling like this  ```  Hooman anik = new Hooman(\"Anik\",22);  anik.showSomeCharacter(); // General characteristics -------(a)  Hooman.showSomeCharacter(); // General characteristics -----(b)  ```  - `(a)` is ok but `not recommended`,  - `(b)` best practice,## Special `main()` method- Special method having `public`,`static`, `void`, method name `main` and having a `String array` as parameter,  ```java  public static void main(String[] args) {    // entry point of execution  }  ```- `JVM invokes this method`. If not found, then JVM does not know where to start the application. So, it throws an error stating that no main() method was found,- You can have as many as `main()` method in a class having different signature. But JVM will call only the above one,- You don't need to write main method in a class if you don't want it to start from here,- You can also call `main()` method just like other method,- Ex: See `Test.java`,   ```java  public class Test {      public static void main(String[] args) {         ...      }      ...  }  ```## Invoking/Calling method- `Instance` method is invoked on an `instance of the class` using dot(`.`) notation,- `Class method` is invoked on `Class name` using dot(`.`) notation,- Ex: See `main()` in `Test.java`,  ```java  Hooman anik = new Hooman(\"Anik\",22);  anik.showSpecificCharacter(); // instance    Hooman.showSomeCharacter(); // static  ```## Constructor- Used to `initialize an object` of a class,- Constructor name is the same as the simple name of the class,- Doesn't have return type,- Basic Structure(can have `throws` clause also):  ```java  <<Modifiers>> <<Constructor Name>>(<<parameters list>>){   // Body of constructor goes here  }  ```- Overloading of constructor is possible,- If a class has multiple constructors, all of them must differ from the others in the `number`, `order`, or `type` of parameters,- One constructor can call other constructor,- `Access modifiers` are same as others,- By default, `JVM` adds a `default constructor` as long as there is no constructor.- `default constructor` doesn't accept any parameter and does nothing,- `default constructor` only satisfies logic so that we can create object,- You can't declare a constructor `static`. Remember `static` is part of class not object,- Ex: See `Bird.java`,  ```java  public class Bird {      ...      // constructor - 1      public Bird() {          this.name = \"Unknown\";          this.species = \"Not found\";          this.canFly = false;      }        // constructor - 2      public Bird(boolean canFly) {          this(\"unknown\",\"Not found\",canFly); // calling other constructor. Remember `this`. must be first line      }        // constructor - 3      public Bird(String name, String species, boolean canFly) {          this.name = name;          this.species = species;          this.canFly = canFly;      }        // constructor - 4 . Copy constructor      public Bird(Bird bird){          this.name = bird.name;          this.species = bird.species;          this.canFly = bird.canFly;      }      ...  }  ```  Creating object like this: See `birdTest()` in `Test.java`:  ```java  private static void birdTest(){      Bird deadBird = new Bird(); // 1      deadBird.printDetails(); // Unknown -> Not found -> false        Bird unknownBird = new Bird(true); // 2      unknownBird.printDetails(); // unknown -> Not found -> true        Bird eagle = new Bird(\"Eagle\", \"Eagle\", true); // 3      eagle.printDetails(); // Eagle -> Eagle -> true        Bird secondEagle = new Bird(eagle); // 4      secondEagle.printDetails(); // Eagle -> Eagle -> true  }  ```## Creating instance of a class- Object can be created by calling its constructor.- Ex: `new Hooman();`, This object will be automatically deleted, since we are not assigning it in any variable.- When you create an object using `new` keyword, it allocates memory for each `instance field` of the class,- Java runtime takes care of memory allocation, you don't need it,- Creating object and calling method:  ```java  Hooman saeed = new Hooman(\"Saeed\",21);  System.out.println(saeed.isAdult()); // true  ```>> THERE IS NO SHORTCUT OTHER THAN PRACTICING<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/operator/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/classesandobject/part2/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"classesandobject","subTopicName":"classesandobject","topic":{"topic_name":"classesandobject","no_of_sub_topics":3,"folder_name":"classesandobject","serial":2},"serial":1}},{"blogPK":{"topicName":"classesandobject","subTopicName":"classesandobject"},"content":"# Classes and Object - part2## Local variable- Variable declared inside `method`, `constructor`, `block`,- Formal parameters for a method are treated as local variables,- `Not initialized` by default,- Can't be used until it is assigned a value. Will show `error` instead of garbage value,- Must be declared before it is used,- If variables having same name found, local variable get precedence,- See `LocalVariable.java` for full code,  ```java  public class LocalVariable {      ...      private int num; // global, value = 0      ...        public void assignMust(){          int num; // local, no default value          //System.out.println(num); // error. Not initialized.      }        public int calculateDifference(int num2){          int num = 1001; // local          System.out.println(num); // 1001 since local get precedence          return this.num - num2; // this.num refers to global num      }  }  ```## Null- A `special reference type` called `null type`,- It has no name,- `Assignment compatible` with any other `reference` type. Ex:  ```java  String name = null; // ok  Integer number = null; // ok  Hooman none = null; // ok  int count = null; // error. int is not reference type. Remember?  ```- After making `sh = null;`, the object `sh` was referring will be destroyed by JVM, since it is no longer accessible.  ```java  Hooman sh = new Hooman(\"sh\",22);  sh = null;  ```## this- Extremely useful keyword,- Reference to the `current instance` of a class. (Alert it's for `instance`, not class),- Can be used only in the context of an `instance/object`,- Ex: See `TriState.java`,  ```java  public class TriState {      ...      private StateEnum state = StateEnum.FIRST; // will be discussed later      public TriState(StateEnum state) { // state = SECOND is passed          System.out.println(this.state); // FIRST          System.out.println(state); // SECOND          this.state = state; // this.state refers to the global state --- (a)      }      ...  }  ```- Creating instance of above class  ```java  TriState triState = new TriState(SECOND);  System.out.println(triState.state); ---- (b)  ```- `triState.state` in outside is same as `this.state` inside the class for a specific object of the class. See `(b)` and `(a)`.- Practice yourself,## final- `prevent modification` on which it is used,- For declaring `constant`,- Can be used in the following `3` contexts:  - `Variable`    - Can be `assigned` a value `only once`,    - `Can't reassign` after assigning,    - Can be assigned while declaration or later,    - If you do not initialize a final variable at the time of its declaration, such a variable is known as a `blank final` variable,    - Ex:       ```java      final int total;      ```  - `Class`:    - final class can't be `extended` or `inherited`,  - `Method`:    - final method can't be `redefined` (`overridden` or `hidden`) in the `subclasses`,## final local variable && final parameter  - Ex: See `getArea()` of `Test.java`:    ```java    private static double getArea(final double r){ // final parameter       final double pi = 3.1415; // final local variable       //pi = 3; // error       //r = 5; // error       return pi*r*r;    }    ```## final instance variable- Can be `final` or `blank final`,- `Rules` apply for `initializing` a `blank final` instance variable:  - Must be initialized in `one of the instance initializers` or in `all` constructors,  - Don't be confused. Just remember that you can only `assign value at once`. If you try to reassign it, you will get error,- All `blank final` variables and `final reference variables` are runtime constants. i.e. they are calculated at runtime,- Ex: See `Circle.java`,  ```java  public final class Circle {        public static final double PI = 3.14159; // final        private final double r; // blank - final        public Circle() {          this.r = 0;      }        public Circle(double r) {          this.r = r;      }        public Circle(Circle c){          this(c.r); // it will assign value          //this.r = c.r; // error, since already assigned in previous line      }        public double getArea(){          return PI * r * r;      }    }      ```## final class variable- Same like previous,- Good practice to use `capital letter` for variable naming,- Ex:  ```java  public static final double PI = 3.14159;  ```## Varargs- Full form is `variable-length arguments`,- Can be used both in method and `constructor`,- 3dots(`...`) is used,- We can pass any number of arguments, parameter will work like `array`. But we don't have to pass array explicitly,- Ex: See `max()` in `Test.java`,  ```java  private static int max(int... arr){      if(arr.length == 0) return 0;      int mx = Integer.MIN_VALUE;      for(int num : arr){          if(num > mx) mx = num;      }      return mx;  }  ```  Using like this:  ```java  System.out.println( max() ); // 0  System.out.println( max(1,22) ); // 22  System.out.println( max(1,2,3,4,5,6,7,8,10) ); // 10  ```- Isn't it awesome?- There is `2` restriction:  - A varargs method can have `maximum one varargs`,     ```java     // n1 has infinite length, so n2 is not needed. error      void m1(String str, int...n1, int...n2) {         ...      }     ```  - The varargs `must be the last argument` in the argument-list. Same reason even though parameter type is different.     ```java     void m2(int...n1, String str) {      ...     }    ```    This is perfectly valid: See `findMinMax()` `Test.java`,     ```java     private static int findMinMax(boolean findMax, int ...arr){...}     ```## Generic class- Allows for writing `true polymorphic` code(Works for any types),- Structure:  ```java  public class Wrapper<T> {   // Code for the Wrapper class goes here  }  ```- `T` is a `type variable`. It can be of any type, but must be reference type,- Ex: See `MyList.java`,  ```java  public class MyList <T>{      private final List<T> list = new ArrayList<>();            public MyList() {}        public void add(T item){          list.add(item);      }        public T get(int index) throws ArrayIndexOutOfBoundsException{...}    }  ```  Using like this: See `simpleGenericTest()` in  `Test.java` ,  ```java  private static void simpleGenericTest(){    MyList<Integer> myList = new MyList<>();    //MyList myList = new MyList<>(); // ok but not recommended.    myList.add(12);    myList.add(32);    myList.add(42);    myList.add(62);      //System.out.println( myList.get(5) ); // Index out of bound      System.out.println( myList.get(1) ); // 32  }  ```- Above one is a simple example. Learn more by yourself if you want to,<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/classesandobject/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/classesandobject/part3/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"classesandobject","subTopicName":"classesandobject","topic":{"topic_name":"classesandobject","no_of_sub_topics":3,"folder_name":"classesandobject","serial":2},"serial":2}},{"blogPK":{"topicName":"classesandobject","subTopicName":"classesandobject"},"content":"# Classes and Object - part3## Parameter passing in java## Before passing parameter, let us clear these concepts- Remember, JAVA supports 2 types of data type.- `primitive`:   - `Stores value directly` at its memory address,- `reference`:  - `Stores the reference` of the object which is located in `Heap`,- See this image: `1st` one is `primitive`, `2nd` one is `reference`,<img src=\"../files/primitive_and_reference_data.png\" height=\"200px\" alt=\"Primitive & Reference data type\">- Every `variable name` has `2` things associated with it:   - a memory address(`lvalue`),  - a value stored at that memory address(`rvalue`),- For `primitive data type`, memory address hold `actual data`,- For `reference data type`, memory address hold the `reference of actual data`,- Ex:  ```java    Hooman sd = new Hooman(\"sh\",22);    Hooman sh = new Hooman(\"sd\",23);    sh = sd; ----(a)    ```- `lvalue` stores `rvalue` and here `rvalue` is reference of Hooman object.- For `(a)`, it is interpreted as    ```    lvalue of sh = rvalue of sd    ```  it means that memory address of `sh` will store the reference of the object to which `sd` is pointing.## Back to parameter passing again- All parameters in Java are `passed by value`,- No way to pass by reference in JAVA,- The `memory address with data` is `copied` into different memory address then passed to method,- For `primitive` data type,  - Memory address holds `actual value`,  - So, data is actually copied & it is `truly pass by value`,- But for `reference` data type,  - The memory address(`lvalue`) holds the `reference of actual data`, not the actual data,  - So, `lvalue` with same reference variable is passed,  - So, `lvalue` is copied but both are pointing to same object,  - As a result, if we make any change in the object inside method, it will take effect in passed data,- Ex: See `Student.java` & `Test.java`,  ```java  public class Student {      private int roll;      private String name;      private int age;      ...  }  ```  Using like this:  ```java  public class Test {      private static void printInfo(Student student){          System.out.println(student.getRoll()); // 6          System.out.println(student.getName()); // Hasib          System.out.println(student.getAge()); // 21            // actual data won't be changed. Remember, lvalue is copied but both point to same object          student = new Student(18,\"Rifat\",23); // will make lvalue to point different object. But won't affect actual data      }        private static void printInfoAdvanced(Student student){          System.out.println(student.getRoll()); // 12          System.out.println(student.getName()); // Imran          System.out.println(student.getAge()); // 21            student.setRoll(25);          student.setName(\"Prottoy\");          student.setAge(21);          // above 3 lines change the properties of the object to which student is pointing. This is changing the properties of object, so affect actual data      }        public static void main(String[] args) {          Student hasib = new Student(6,\"Hasib\",21);          printInfo(hasib);          System.out.println(hasib.getName()); // Hasib            Student imran = new Student(12,\"Imran\",21);          printInfoAdvanced(imran);          System.out.println(imran.getName()); // Prottoy      }        }  ```- See this image also<img src=\"../files/primitive_reference_passing.png\" height=\"180px\" alt=\"Primitive & Reference data type\"><!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/classesandobject/part2/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/theobjectclass/part1/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"classesandobject","subTopicName":"classesandobject","topic":{"topic_name":"classesandobject","no_of_sub_topics":3,"folder_name":"classesandobject","serial":2},"serial":3}},{"blogPK":{"topicName":"theobjectclass","subTopicName":"theobjectclass"},"content":"# The Object Class - part1## Introduction- Available in `java.lang` package,- `Superclass` of all classes,- All java classes extends this `Object` class indirectly,## 2 important rules of Object class:- `(Rule-1:)`A variable of `Object` class can hold a reference of an object of any class. Because  - `Object` class is the superclass of all classes,  - Since variable of superclass can hold object of its subclasses. So,  - A variable of `Object` class can hold a reference of an object of any class,  - Ex: See `ruleTest1()` in `Test.java`,    ```java    private static void ruleTest1(){            Object myObj = new Object();            String name = \"hello\";        Object nameObj = name; // ok            Object name2 = \"hello\"; // ok        System.out.println(name2); // hello                Exception exception = new Exception(\"anything\");        Object ex = exception; // ok    }    ```- `(Rule-2:)` The Object class has `9` methods, which are available to be used in all classes in Java  - We can put the methods into two categories:  - Category - 1:    - `Can't override` these methods,    - Implementation is `final`,    - Methods are:       - `getClass()`,       - `notify()`,       - `notifyAll()`,       - `wait()`  - Category - 2:    - Have a `default implementation` in the Object class,    - `Can override` these methods,    - Methods are:      - `toString()`,      - `equals()`,       - `hashCode()`,       - `clone()`,       - `finalize()`  - Details of methods:  <img src=\"../files/method_of_object_class.jpg\">  - `Implemented` means method have `default implementation`,  - `Customizable` means method can be `overridden`,## `getClass()` method- Returns the `reference` of the Class object,- Ex: See `testGetClass()` in `Test.java`,  ```java  private static void testGetClass(){      Cat cat = new Cat(\"Cat\");      Class<?> catClass = cat.getClass();        System.out.println(catClass); // class theobjectclass.part2.Cat        System.out.println(catClass.getName()); // theobjectclass.part2.Cat        System.out.println(catClass.getSimpleName()); // Cat  }  ```## Hash code- Learn `Hashing` or ignore it, since it is already implemented & you may never `override` it, - By using an `algo`, form a `piece of info`, an `integer value` is generated(`hashing`),- Every object has a `hash-value`,- Used for efficiently retrieving data from hash based collections like `Hashtable`, `HashMap` etc,- The Object class has a `hashCode()` method that returns an `int`, which is the hash code of the object,- `hashCode()` is already implemented, but you can `override` it,(`no need to override`),- Rules when you `override` the `hashCode()` method in your class:  - Suppose you have `2` variables `x`, `y` referring object of your class,  - If `x.equals(y)` returns `true`, then    - Hash of `x` and `y` must be same. i.e.,    - `x.hashCode() = y.hashCode()`,  - Opposite of above is not true. i.e. if `x.hashCode() = y.hashCode()` then `x.equals(y)` may not be true,  - `hashCode()` should generate same value if it is called on same object,  - Use only those instance variables to compute hash code for an object, which are also used in `equals()` method to check for equality,- See `hashCode()` of `Student.java`,  ```java  public class Student {      private final int roll;      private final String name;      private int age;      private double height;        ...        @Override      public int hashCode() {  //        return super.hashCode(); // default implementation          int hash = 37;            int code = roll;          hash += 17 * hash + code;            code = (name == null ? 0 : name.length());          hash += 17 * hash + code;            code = age;          hash += 17 * hash + code;            code = (int)height;          hash += 17 * hash + code;            return hash;      }      ...  }  ```  Using like this. See `hashTest()` of `Test.java`,  ```java  private static void hashTest(){        Student saeed = new Student(57,\"Saeed\",21,170);      Student jakaria = new Student(56,\"Jakaria\",22,171);      Student saeedAgain = new Student(57,\"Saeed\",21,170);        System.out.println(saeed.hashCode()); // 4218704      System.out.println(jakaria.hashCode()); // 4213539      System.out.println(saeedAgain.hashCode()); // 4218704  }  ```## Comparing Objects for Equality- All objects have a `unique identity`,- The `memory address` at which an object is allocated can be treated as its `identity`,- Ex: See `Student.java`,  ```java  public class Student {      private final int roll;      private final String name;      private int age;      private double height;      ...      @Override      public int hashCode() { ... }            @Override      public boolean equals(Object obj) {          //return super.equals(obj); // default implementation            if(this == obj){ // same reference              return true;          }            if(!(obj instanceof Student)) { // object of different classes              return false;          }                    if(hashCode() != obj.hashCode()){ // different hashCode, so can't be same              return false;          }                    Student item = (Student)obj;            return roll == item.roll && name.equals(item.name) && age == item.age && height == item.height;      }    }  ```  Using like this. See `equalsTest()` of `Test.java`,  ```java  private static void equalsTest(){        Student saeed = new Student(57,\"Saeed\",21,170);      Student jakaria = new Student(56,\"Jakaria\",22,171);      Student saeedAgain = new Student(57,\"Saeed\",21,170);        Cat cat = new Cat(\"Happy\");        System.out.println(jakaria.equals(jakaria)); // true - since same reference        System.out.println(cat.equals(saeed)); // false - object of different classes      System.out.println(saeed.equals(jakaria)); // false - different hashCode values        System.out.println(saeed.equals(saeedAgain)); // true - values are same  }  ```## String Representation of an Object- Contains enough information about the `state of the object`,- Used for `debugging` purpose(Advanced debugging tools are available though),- Has a default implementation, but not much useful,  - Ex: See `defaultEqualsTo()` of `Test.java`,    ```java    private static void defaultEqualsTo(){        Cat cat = new Cat(\"Happy 3X\");        System.out.println(cat.toString()); // theobjectclass.part2.Cat@7a81197d        System.out.println(cat); // theobjectclass.part2.Cat@7a81197d        //above two statements are equivalent    }    ```- Let's `override` according to our need,- Ex(custom implementation): See `Student.java`,  ```java  public class Student {      private final int roll;      private final String name;      private int age;      private double height;      ...        @Override      public String toString() {          //return super.toString(); // default          return \"roll: \" + roll + \", \" + \"name: \" + name + \", \" + \"age: \" + age + \", \" + \"height: \" + height;      }  }  ```  Using like this: See `customEqualsTo()` of `Test.java`,  ```java  private static void customEqualsTo() {        Student atik = new Student(38,\"Atik\",22,168);      System.out.println(atik.toString()); // roll: 38, name: Atik, age: 22, height: 168.0          Student galib = new Student(35,\"Galib\",22,-173);        int heightInFeet = (int)(galib.getHeight() / 39);      System.out.println(heightInFeet); // -4        //finding that problem      System.out.println(galib.toString()); // roll: 35, name: Galib, age: 22, height: -173.0        galib.setHeight(173);        heightInFeet = (int)(galib.getHeight() / 39);      System.out.println(heightInFeet); // 4  }  ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/classesandobject/part3/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/theobjectclass/part2/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"theobjectclass","subTopicName":"theobjectclass","topic":{"topic_name":"theobjectclass","no_of_sub_topics":2,"folder_name":"theobjectclass","serial":3},"serial":1}},{"blogPK":{"topicName":"theobjectclass","subTopicName":"theobjectclass"},"content":"# The Object Class - part2## Cloning Objects- Java doesn't provide an automatic mechanism to clone (make a copy) an object,- For two reference variable `x` & `y`,  - `x = y`,(Assigning `y` into `x`)    - Copy reference of `y` into `x`,     - Doesn't copy the content of the object that `y` refers to,- For cloning , you must implement `Cloneable` interface to your class. Why? See `Marker interface` in interface section,- `clone()` method in `Object` class is as follows:  ```java  protected Object clone() throws CloneNotSupportedException  ```- `clone()` method  - It is `protected`, so you must `override` it for using in your class,  - Return type is `Object`. So, you have to cast it after cloning,  - You do not need to know any internal details of it,   - The `clone()` method in the Object class has all the code that is needed to clone an object,  - Just call the `clone()` method of your class,  - It will make a `bitwise copy` of the original object and return the reference of the copy,  - Ex-1: See `Student.java`,  ```java  public class Student implements Cloneable{      ...      @Override      protected Object clone() {          try {              return super.clone(); // calling default clone()          }catch (CloneNotSupportedException e){              return null;          }      }  }  ```  Calling like this: See `cloneTest()` in `Test.java`,  ```java  private static void cloneTest(){        Student who = new Student(269,\"who\",23,173);        System.out.println(who); // roll: 269, name: who, age: 23, height: 173.0        Student copied = (Student) who.clone();        System.out.println(copied); // roll: 269, name: who, age: 23, height: 173.0        copied.setAge(30);      System.out.println(copied); // roll: 269, name: who, age: 30, height: 173.0      System.out.println(who); // roll: 269, name: who, age: 23, height: 173.0  }  ```  As you can see, after changing cloned object, it is not affecting original object,- Ex-2: See `Cat.java`, `Human.java`,  ```java  public class Human implements Cloneable{      private String name;      private Cat cat;      ...        @Override      public String toString() {          return \"owner: \" + name + \", \" + \"catName: \" + cat.getName();      }        @Override      protected Object clone() {          try {              return super.clone();          }catch (CloneNotSupportedException e){              e.printStackTrace();              return null;          }      }    }  ```  Calling like this: See `cloneTest2()` in `Test.java`,  ```java  private static void cloneTest2(){      Human tomal = new Human(\"Tomal\",\"Loki\");        System.out.println(tomal); // owner: Tomal, catName: Loki        Human copied = (Human) tomal.clone();        System.out.println(copied); // owner: Tomal, catName: Loki        copied.setName(\"Totomal\");      System.out.println(tomal); // owner: Tomal, catName: Loki      System.out.println(copied); // owner: Totomal, catName: Loki        copied.setCatName(\"kilo\");      System.out.println(tomal); // owner: Tomal, catName: kilo <--------------------      System.out.println(copied);// owner: Totomal, catName: kilo <-------------------            }  ```  As you can see even after cloning the main object, when we change the nested object, actual object is affected.- For solving this issue, you must handle this manually.- See commented `clone()` of `Human.java`:  ```java  @Override  protected Object clone() {      try {          Human human = (Human) super.clone();          human.cat = (Cat)this.cat.clone();          return human;      }catch (CloneNotSupportedException e){          e.printStackTrace();          return null;      }  }  ```  Result is(Perfectly fine):  ```java  private static void cloneTest2(){      Human tomal = new Human(\"Tomal\",\"Loki\");      System.out.println(tomal); // owner: Tomal, catName: Loki        Human copied = (Human) tomal.clone();      System.out.println(copied); // owner: Tomal, catName: Loki        copied.setName(\"Totomal\");      System.out.println(tomal); // owner: Tomal, catName: Loki      System.out.println(copied); // owner: Totomal, catName: Loki        copied.setCatName(\"kilo\");      System.out.println(tomal); // owner: Tomal, catName: Loki      System.out.println(copied);// owner: Totomal, catName: kilo  }  ```## Finalizing an Object- Sometimes an object uses resources that need to be released when the object is destroyed,- In Java, you create objects, but you `cannot destroy objects`,- `Garbage Collector` handles object destruction part. But,- It gives a trigger before destroying object by calling `finalize()` method,- `finalize()` method:  - Structure:    ```java    protected void finalize() throws Throwable {    ```  - Doesn't do anything,  - is called when `garbage collector` determines that no reference exists for the object,  - **It is not even guaranteed that a finalizer will run at all. So avoid relying on it for cleanup,**  - `Deprecated` and will be `removed` in the future,- Ex: Try yourself like `finalizeTest()` in `Test.java`,## Immutable objects- Object whose state `cannot be changed` after it is created,- A class whose objects are `immutable` is called an `immutable-class`,- If an object’s state `can be changed` after it has been created, it is called a `mutable object`, and its class is called a `mutable-class`,- Two views of an object’s state:  - `internal`: Defined by the actual values of its instance variables at a point in time,  - `external`: Defined by the values that the users of the object see at a point in time, - `An immutable object` means `external immutability`,- Advantages:  - Can be shared without worrying about changes,  - Testing an immutable class is easy,  - Thread safe since can't be changed,- Ex of mutable class: See `immutableTest()` in `Test.java`,  ```java  private static void immutableTest(){      Cat cat = new Cat(\"Oscar\");      System.out.println(cat.getName()); // Oscar        cat.setName(\"Billi\"); // state changed < - - - - -      System.out.println(cat.getName()); // Billi  }  ```- Immutable version of `Cat` class will be like this. See `GammaCat.java`,  ```java  public class GammaCat {      private final String name; // <------- final optional though, since private and no setter        public GammaCat(String name) { this.name = name; }        public String getName() { return name; }            @Override      protected Object clone(){          try {              return super.clone();          }catch (CloneNotSupportedException e){              e.printStackTrace();              return null;          }      }        @Override      protected void finalize() throws Throwable {          System.out.println(name);      }    }  ```  Just remove the ways that can make changes in the variable. Here `setName()` is removed and variable is private. So there is no way change the variable.- If you want to make your class `immutable` and your class contains reference of any other classes, then make sure to make those reference classes `immutable`,- For ex: for making `Human` class immutable, you have to make `Cat` class immutable also,- So, for making a class `immutable`,  - Make all instance variable `final`,(Optional, but compiler will ensure immutability),  - Make all references class `immutable`,  - Remove methods that can change variables state (Setter methods).<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/theobjectclass/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/wrapperclass/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"theobjectclass","subTopicName":"theobjectclass","topic":{"topic_name":"theobjectclass","no_of_sub_topics":2,"folder_name":"theobjectclass","serial":3},"serial":2}},{"blogPK":{"topicName":"exceptionhandling","subTopicName":"exceptionhandling"},"content":"# Exception Handling - part1## Exception- A condition that may arise during the execution when a normal path of execution is not defined.- Ex: See `firstTest()` in `Test.java`    ```java    private static void firstTest(int y){        int x = 10;        int result = (x/y); // will throw exception if y == 0        System.out.println(result);    }    ```- In above example, 3rd line inside method won't be executed because `2nd line break normal execution`, since integer can't be divided by zero(`0`),- Above example can be written using `if-else`, but it will make code complex if there are many such condition,- Equivalence `if-else` code(See `firstTestBadSolution()` in `Test.java`):    ```java    private static void firstTestBadSolution(int y){        int x = 10;            if(y == 0){            System.out.println(\"Can't divide\"); // Can't divide        }        else{            int result = x/y;            System.out.println(result);        }    }    ```- Solution to above problem(See `firstTestSolution()` in `Test.java`):     ```java    private static void firstTestSolution(int y){        int x = 10;        try {            int result = x/y;            System.out.println(result);        }        catch (ArithmeticException e){            System.out.println(\"Can't divide\"); // executed when y = 0        }    }    ```- Structure:    ```java    try {         // code that may cause error    }    catch(Exception e){ -------------(c)     // catch all types of exception    }    ```- All the types of exception are `class`. For example `Exception` in `(c)` is a class in java,- Hierarchy:- <img src=\"../files/exception_hierarchy.jpg\" height=\"220px\">- `catch(Throwable t){}` i.e. parameter of catch must be of `Throwable` or any of its subclass. Remember, object of parent class can refer object of its subclass,## Multiple class block- We can have multiple catch block,- Multiple catch blocks for a try block must be arranged from the most specific exception type to the most generic exception type. Otherwise, a compile-time error occurs,- Ex: (Compile time error) because `ArithmeticException` is child of `RuntimeException`,    ```java    private static void catchExceptionOrder(int y, String message, String filePath){        try{        ...        ...        ...        }        catch (IOException e) {...}        catch (RuntimeException e){...}        catch (ArithmeticException e){...}    }    ```- Valid code: (See `catchExceptionOrder(int,String,String)` in `Test.java`)    ```java    private static void catchExceptionOrder(int y, String message, String filePath){        try{            ...            ...            ...         }        catch (IOException e) {...}        catch (ArithmeticException e){...}        catch (RuntimeException e){...}    }    ```- Multiple catch block can also be written like this: See `catchMultipleException()` in `Test.java`,  ```java  private static void catchMultipleException(int y, String message, String filePath){      try {          ...      }      catch ( RuntimeException | IOException e){ // < -- - -- - --          System.out.println(\"Something went wrong\");      }  }  ```## Transfer of control in `try-catch`:- <img src=\"../files/control_transfer_in_exception.jpg\" height=\"220px\">- Only one catch block will be executed based on the type of exception thrown,- JVM will check each catch block from the first, as soon as it finds a catch block that can handle this exception, that block will be executed,## Unchecked exception- Compiler does not check if they are handled in the code,- May or may not be handled by you, compiler doesn't show error,- Lower possibility of occurrence,- Ex: (see `exception_hierarchy.jpg`)    - The Error class and its subclasses,    - The RuntimeException class all its subclasses- In previous example `IOException` must be handled if code inside try block can throw IOException,## Checked exception- Compiler checks if they are handled in the code,- Must be handled i.e. must have corresponding catch block, otherwise compile time error,- Higher possibility of occurrence,- Ex: (see `exception_hierarchy.jpg`)   - The `Throwable` class,  - The `Exception` class,   - Subclasses of the `Exception` class, except `RuntimeException class and its subclasses`,- In previous example: catch block for `ArithmeticException` & `RuntimeException` is optional,## Handling Checked Exception - Can be handled in two ways,  - Using catch block(previous one),  - Adding in method signature,- Two ways are shown: See `handleChecked1()` & `handleChecked2()` in `Test.java`,    ```java    private static void handleChecked1(String filePath){        try {            FileReader fileReader = new FileReader(filePath);            printFile(fileReader);            fileReader.close();        }catch (IOException e){            System.out.println(\"Failed to read\");        }    }    ```    or    ```java    private static void handleChecked2(String filePath) throws IOException{        FileReader fileReader = new FileReader(filePath);        printFile(fileReader);        fileReader.close();    }    ```- Can be called using: See `callHandleChecked()` in `Test.java`,    ```java    private static void callHandleChecked(){        handleChecked1(\"invalid\");            try {            handleChecked2(\"invalid\");        }catch (IOException e){            System.out.println(\"Failed to read\");        }    }    ```- What did you learn? You must handle checked exception:  - Either inside method using try-catch or,  - While calling method(somewhere in call stack) using try-catch,## Throwing an Exception- You can also throw exception if you want,- Ex: See `throwMyException()` in `Test.java`,    ```java    private static void throwMyException(int age) throws Exception{        if(age < 18) throw new Exception(\"You are baccha\");            System.out.println(\"fine\");    }    ```    Can be called like: See `testThrow()` in `Test.java`.    Without exception:    ```java    try {        throwMyException(20); // fine    }catch (Exception e){        System.out.println(e.getMessage());    }    ```    With exception:    ```java    try {        throwMyException(12);    }catch (Exception e){        System.out.println(e.getMessage()); // You are baccha    }    ```## Creating own Exception class- Custom exception class can be created by inheriting/extending existing class,- Ex: See (`MyException.java`, `MyMessage.java` and `testMyException()` in `Test.java`)   ```java  private static void testMyException(MyMessage myMessage) throws MyException{      if(myMessage.getMessage() == null){          throw new MyException(myMessage);      }      System.out.println(myMessage.getMessage()+\" \"+myMessage.getMessageId());  }  ```## finally block- Gets executed no matter how the code in the try and catch blocks,- Ex: See `finallyTest()` in `Test.java`,    ```java    private static void finallyTest(String filePath){        FileReader fileReader = null;        try {            ...        }catch (IOException e){...}        finally {            if(fileReader != null){                try {                    fileReader.close();                    System.out.println(\"finally executed\");                }catch (IOException e){e.printStackTrace();}            }        }    }    ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/wrapperclass/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/exceptionhandling/part2/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"exceptionhandling","subTopicName":"exceptionhandling","topic":{"topic_name":"exceptionhandling","no_of_sub_topics":2,"folder_name":"exceptionhandling","serial":5},"serial":1}},{"blogPK":{"topicName":"exceptionhandling","subTopicName":"exceptionhandling"},"content":"# Exception Handling - part2## Rethrowing an Exception- Can be rethrown i.e. can be thrown from `catch` block,- Can be used for  - Propagating exception to calling method,  - Wrapping exception into another exception,  - Hiding exception details from client,- Structure:    ```java    try {     ...    }    catch(MyException e) {     throw e; // Rethrowing the same exception    }    ```- Rethrown exceptions must be caught from another outer `try-catch` block,- Ex: See `rethrowException()` in `Test.java`,  ```java  private static void rethrowException(int y){      try{          ...      }catch (Exception e){          throw new RuntimeException(\"Can't divide by zero\");      }  }  ```  When calling(See `testRethrow()` in `Test.java`),  ```java  try {      rethrowException(0);  }catch (Exception e){      e.printStackTrace(); // executed  }  ```- It can also be handled like this:  ```java  try { // outer, will catch rethrown exception      try { // innner          ...      } catch (Exception e) {          throw new RuntimeException(\"Can't divide by zero too\");      }  }catch (Exception e){      e.printStackTrace(); // executed  }  ```- Location of exception can also be hidden by using `fillInStackTrace()` method,- Ex: See `m2()`, `m1()` & `hideTrace()` in  `Test.java`,  ```java  public static void hideTrace() {      try {          m1();      }      catch(Exception e) {          e.printStackTrace(); // hidden original trace      }  }  public static void m1() throws Exception {      try {          m2();      }      catch(Exception e) {          e.fillInStackTrace(); // hide trace here -----(a)          throw e; // rethrowing      }  }  public static void m2() throws Exception {      throw new Exception(\"An error has occurred.\"); // just throw  }  ```  - Stack trace with `(a)`:    ```log    java.lang.Exception: An error has occurred.          at exceptionhandling.part2.Test.m1(Test.java:19)          at exceptionhandling.part2.Test.hideTrace(Test.java:7)          at exceptionhandling.part2.Test.main(Test.java:74)    ```  - Stack trace without `(a)`:    ```log    java.lang.Exception: An error has occurred.            at exceptionhandling.part2.Test.m2(Test.java:25)            at exceptionhandling.part2.Test.m1(Test.java:16)            at exceptionhandling.part2.Test.hideTrace(Test.java:7)                    at exceptionhandling.part2.Test.main(Test.java:76)    ```  - Practice yourself to understand clearly,  ## Throwing too Many Exceptions- Can be thrown as many as exception you want,- Ex: See `throwMultiple()` in `Test.java`,  ```java  private static void throwMultiple(Integer y) throws RuntimeException{      if(y == null) throw new NullPointerException(\"Can't be null\");        if(y == 0) throw new ArithmeticException(\"Can't be zero\");        System.out.println(\"ok\");  }  ```## Accessing the Stack of a Thread- Each thread is allocated a stack to store its temporary data,- A thread stores the state of a method invocation onto its stack,- When a method is called, it is pushed into the stack,- When method execution is completed, it is popped from stack,- Suppose we call a method `m1()` from `main()` then,  - Stack content (from `m1()`) will be     - `m1()` on top,    - `main()` on bottom  - Stack content (from `main()`) will be    - `main()` on top    - Because `m1()` is completed and popped from stack,- For getting stack content at any given time, we can create an object of the `Throwable` class (or any `Exception` class), it captures the stack of the thread that is executing,  ```  Throwable t = new Throwable();  StackTraceElement[] frames = t.getStackTrace(); // will return current stack content  ```- See `StackFrameTest.java` for more,## The try-with-resources Block- For closing object of any resources such as `File`,- It can be done using `finally` also,- Structure  ```java  try (AnyResource aRes = create the resource...) {   // Work with the aRes here  }  ```- A resource that you specify in a try-with-resources must be of the type java.lang.AutoCloseable,- When the program exits the try-with-resources block, the `close()` method of all the resources is called automatically,- Equivalent code using finally  ```java  AnyResource aRes;  try {    aRes = create the resource...;  }  finally {    try {     if (aRes != null) aRes.close();    }    catch(Exception e) {      e.printStackTrace();    }  }  ```- So, `try-with-resource` make code simpler,- Ex: see `MyResource.java` & `Test2.java`  ```java  public class MyResource implements AutoCloseable{      private MyMessage myMessage;      ...        public MyResource(String message, int id, String sender) {...}      ...            @Override      public void close() throws Exception { // must          myMessage = null;          System.out.println(\"Closed \"+sender);      }  }  ```  See `testTryWithResource()` in `Test.java`,  ```java  private static void testTryWithResource(){      try(              MyResource res1 = new MyResource(\"Hello world!\",1,\"Saeed\");              MyResource res2 = new MyResource(\"Hi world!\",2,\"None\");      ){          System.out.println(res1.getSender()); // Saeed          System.out.println(res2.getSender()); // None      }      catch (Exception e){          System.out.println(\"Something went wrong\");      }      // Closed None. JVM automatically call close method on res2      // Closed Saeed. JVM automatically call close method on res1      System.out.println(\"Resource will be closed before this\"); // Resource will be closed before this  }  ```- Output  ```text  Saeed  None  Closed None  Closed Saeed  Resource will be closed before this  ```- It's actually useful. Just make sure your resource class implements `AutoCloseable` & has `close()` method,<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/exceptionhandling/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/assertion/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"exceptionhandling","subTopicName":"exceptionhandling","topic":{"topic_name":"exceptionhandling","no_of_sub_topics":2,"folder_name":"exceptionhandling","serial":5},"serial":2}},{"blogPK":{"topicName":"assertion","subTopicName":"assertion"},"content":"# assertion### Introduction- State `something` in a strong, confident, and forceful way,- When you assert `something`, you believe that `something` to be true,- But it does not make that `something` always true,- Sometimes you may be wrong and that `something` may be false, even if you assert it to be true,### Why assertion- Helps to debug code in development and testing phase,- Used for detecting logical errors in a program,### assertion- Can be written in 2 ways:  - `assert booleanAssertionExpression;`    - This form is enough in almost all cases,  - `assert booleanAssertionExpression : errorMessageExpression;`    - `errorMessageExpression`: allows writing custom error message. Can be any data type,- If `booleanAssertionExpression` evaluates to true, no action is taken. Code is executed normally,- But if evaluates to false, `java.lang.AsssertionError` is thrown,- Assertion is by default disabled. You must run your code using below to see assertion in action:    ```bash    java -ea YourClassName    ```- Ex:    ```bash    java -ea assertion\\Test.java    ```- Ex(See `Test.java`):    ```java    private static void assertType1(){        int a = getNumber(2);            assert a==4;        /*            when we write 4, we know how getNumber(int) works. It helps to debug code.            Because if a != 4, then there must have error in getNumber(int) function        */            // assert a == 6; // will throw runtime exception        System.out.println(a);    }        private static void assertType2(){        int a = getNumber(2);            assert a==6 : \"Something is wrong in getNumber(int)\";            System.out.println(a); // java.lang.AssertionError: Something is wrong in getNumber(int)    }    ```- Must have to run using above command. Otherwise, assertion will be ignored,### Another example:- method definition  ```java    private static int calculateAge(LocalDate localDate){        ...        return (int)age;    }  ```- Calling like:    ```java    LocalDate dob = LocalDate.of(2001,3,21);    int age = calculateAge(dob);        assert age >= 22;    System.out.println(\"I was right\"); // executed    ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/exceptionhandling/part2/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/string/part1/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->","subTopic":{"topicName":"assertion","subTopicName":"assertion","topic":{"topic_name":"assertion","no_of_sub_topics":1,"folder_name":"assertion","serial":6},"serial":0}},{"blogPK":{"topicName":"string","subTopicName":"string"},"content":"# String - part1## Introduction- A sequence of zero or more characters,- Represented by an object of the `java.lang.String` class,- `String` class is `immutable`. i.e., contents of a `String` object can't be modified after it has been created,- Has two companion classes,  - `StringBuilder` & `StringBuffer`  - These are `mutable`,## String Literals- `Literals` means `Constant-value`,- Consists of a sequence of zero or more characters enclosed in `double quotes`,- All `String literals` are `Objects` of the `String` class,  - Ex:  - `\"\"` // empty String literals,  - `Hello world` // String literals of 11 characters- Cannot be broken into two lines,  ```java  // compile-time error  \"He  llo\"  ```- Can be broken into 2 lines by using plus(`+`),  ```java  // valid  \"He\"+  \"llo\"  ```## Escape Sequence in String Literals- Valid to use all `escape sequence characters` to form a string literal,- A character can also be represented as a `Unicode escape` in the form `\\uxxxx`,  - `x` is a hexadecimal digit,- Ex: See `escapeTest()` in `Test.java`,    ```java    private static void escapeTest(){        System.out.println( \"hello\" ); // hello            System.out.println( \"he\\nllo\" );        // he        // llo            System.out.println( \"100%\" ); // 100%        System.out.println( \"Said by \\\"Unknown\\\"\" ); // Said by \"Unknown\"            System.out.println(\"Apple\"); // Apple        System.out.println(\"\\u0041pple\"); // Apple        }    ```- Not used too much,## CharSequence- Is an `interface` in the `java.lang package`,- `String`, `StringBuffer`, and `StringBuilder` implements `CharSequence` interface. So, these can be used wherever `Charsequence` is required,- Ex: See `charSequenceTest()` in `Test.java`,    ```java    private static void printWithLength(CharSequence cs){        System.out.println(cs+\" -> \"+cs.length());    }    ```    ```java    private static void charSequenceTest(){        String name = new String(\"Hello S\");        printWithLength(name); // Hello S -> 7            StringBuffer buffer = new StringBuffer(\"Buffer\"); // will be discussed later        printWithLength(buffer); // Buffer -> 6            StringBuilder builder = new StringBuilder(\"Builder\"); // will be discussed later        printWithLength(builder); // Builder -> 7    }    ```## Creating String Objects- `String` class contains `many constructors` that can be used for creating `String` object,- Ex(Very few constructor): See `stringConstructorTest()` in `Test.java`,    ```java    private static void stringConstructorTest(){        String name;            name = new String(); // empty String        System.out.println(name); //            name = new String(\"Hello\");        System.out.println(name); // Hello            char[] chars = {'1','2','3','4','a','b','d'};        name = new String(chars);        System.out.println(name); // 1234abd            name = new String(chars,3,3); // start from index - 3 & take 3 characters from index-3        System.out.println(name); // 4ab    }    ```## Some properties of String - Every `String` has an `integer` length,   - `length()` method returns number(`int`) of character on that `String` object,   - Ex:     ```java     String name = new String(\"Hello March\");     System.out.println(name.length()); // 11     ``` - All string `literals` are objects of the `String` class,   - All `methods` of the `String` class can be used with `String literals` directly,   - Ex:     ```java     String msg = \"This is Pluto\"; // \"This is Pluto\" is an object     System.out.println(msg.length()); // 13     System.out.println(\"This is Pluto\".length()); // 13     ```## String Objects Are Immutable- You cannot modify the content of a String object,- Can be shared without worrying about them getting modified,- Same String object can be referred by multiple variables, since immutable,- Ex: See `immutableTest()` in `Test.java`,    ```java    private static void immutableTest(){            String var1 = \"Test Case\";        String var2 = var1.substring(0,4);            System.out.println(var1); // Test Case        System.out.println(var2); // Test    }    ```- Whenever you modify a `String`, new `String` is created with the result, performed on 1st `String`,## Comparing Two Strings- Remember, strings are object. So `==` can't be used for comparing,- `int compareTo(String)` can be used for comparing two string objects,- `int compareTo(String)`:  - Returns an integer,  - Zero(`0`): If both are `equals`,   - Positive integer(`>0`): `1st` one is lexicographically `larger` than `2nd`,  - Negative integer(`<0`): `1st` one is lexicographically `smaller` than `2nd`,  - It keeps comparing character by character, if different character is found, it returns `ascii value of that char in 1st` - `ascii value of that char at 2nd`- Ex: See `stringCompareTo()` in `Test.java`,    ```java    private static void stringCompareTo(){        String val1 = \"abc\";        String val2 = \"abc\";        String val3 = \"aBc\";        String val4 = \"zbd\";        String val5 = \"abcd\";            System.out.println(val1.compareTo(val2)); // 0            System.out.println(val1.compareTo(val3)); // 32            System.out.println(val3.compareTo(val1)); // -32 <-----------(a)            System.out.println(val1.compareTo(val4)); // -25        System.out.println(val4.compareTo(val1)); // 25            System.out.println(val1.compareTo(val5)); // -1        System.out.println(val5.compareTo(val1)); // 1    }    ```  - At `(a)`, `val3 = \"aBc\"`, `val1 = \"abc\"` then `val3.compareTo(val1)`:    - 1st character is same, continue    - 2nd character is different. So return `'B'-'b'` which is `66-98 = -32`,    - Doesn't check any other character,## String Pool- Java maintains a pool of all `string literals`,- To minimize the memory usage and for better performance,- It creates a `String object` in the `string pool` for every string literal it finds in a program,- When it encounters a string literal,  - It looks for a `string object` in the `string pool` with the identical content,    - If it doesn't find a match in the `string pool`,       - It creates a new `String object` with that content and adds it to the `string pool`,      - Then, it replaces the `string literal` with the reference of the newly created `String object` in pool,    - If it finds a match in the `string pool`,       - It replaces the `string literal` with the reference of the `String object` found in the pool,- For below statement:    ```java    String str = new String(\"Hello\"); // <---------(a)    ```  - Here `\"Hello\"` is a `String literal`,  - `\"Hello\"` is not in `String pool` initially,  - So `String object`(say `x`) having content `Hello` will be created and added to `String pool`,  - Above statement will be like:    ```java    String str = new String(x);    ```  - Since we are using `new String()`, So another `String object` will be created on the `heap memory`,  - So total `2` String objects will be created for `(a)`,- For these `2` statements below,    ```    String str1 = new String(\"Hello\"); // <---------(c)    String str2 = new String(\"Hello\");// <----------(d)    ```  - Assuming before executing those statements, `String pool` doesn't contain `\"Hello\"`,  - How many `Sting` objects will be created ?  - Answer is `3`. Because    - For `(c)`, `2` string objects will be created,(explained earlier),    - For `(d)`,      - `\"Hello\"` String literal already exists in `String pool`, So no String object will be created in `String pool`,      - Since `new String()` is used in `(d)`, So a `String object` will be created in `heap memory`,  - Total `3` `String object` will be created,- Another ex: See `stringPoolTest()` in `Test.java`,    ```java    private static void stringPoolTest(){        String rohit = \"Rohit\"; // added to pool        String salma = \"Salma\"; // added to pool            String rohitAgain = \"Rohit\"; // not added        String rohitNew = new String(\"Rohit\"); // not added to pool, but created in heap            System.out.println(rohit == salma); // false        System.out.println(rohit == rohit); // true        System.out.println(rohit == rohitAgain); // true, since referring same object in String pool        System.out.println(rohit == rohitNew); // false, Remember new always creates new object            String added = \"Have\" + \"Fun\"; // added to pool        String together = \"HaveFun\"; // not added to pool            System.out.println(added == together); // true, since (\"Have\" + \"Fun\") is evaluated at compile time and result \"HaveFun\" is added to pool            final String constStr = \"Constant\"; // constStr is a constant since final        String s1 = constStr + \" is pooled\"; // \"Constant is pooled\" will be added to the string pool            String res1 = \"Constant is pooled\"; // not added to pool        System.out.println(s1 == res1); // true                String varStr = \"Variable\"; // varStr is not a constant since not final        String s2 = varStr + \" is not pooled\";            String res2 = \"Variable is not pooled\"; // added to pool        System.out.println(s2 == res2); // false    }    ```  - If you have confusion, practice by yourself. Also see the links provided in last part of `String`,- `intern()` method:  - Called as `str.intern()`,  - If `str` is found in pool, then returns that reference,  - If `str` isn't found in pool, then create an object in the `String pool` & return reference of the created object,  - Ex: See `internTest()` in `Test.java`,    ```java    private static void internTest(){        String var = \"My variable\";        String s2 = (var + \" is actually pooled\").intern(); // added to pool            String res = \"My variable is actually pooled\";        System.out.println(s2 == res); // true. without intern() output is false    }    ```>> Actually you don't need to understand all of these<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/assertion/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/string/part2/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"string","subTopicName":"string","topic":{"topic_name":"string","no_of_sub_topics":2,"folder_name":"string","serial":7},"serial":1}},{"blogPK":{"topicName":"string","subTopicName":"string"},"content":"# String - part2## Some String operations- See `testFewOperations()` in `Test.java`,- ### Character at given position:  - `.chartAt(index)`,  - Runtime error if `index` is invalid,  - Ex:    ```java    String str = \"I can write poems\";    System.out.println( str.charAt(2) ); // c    ```- ### Equals check:  - `.equals(str2)` & `.equalsIgnoreCase(str2)`:  - `true` is both strings are completely equal(`1st`),  - `true` if equals after ignoring case(`2nd`),  - Ex:    ```java    String str1 = \"Hello\";    String str2 = \"hello\";    System.out.println( str1.equals(str2) ); // false    System.out.println( str1.equalsIgnoreCase(str2) ); // true    ```- ### Empty check:  - Can be checked in `3` ways,   - Ex:    ```java     String name = \"\";     System.out.println( name.isEmpty() ); // true     System.out.println( name.equals(\"\") ); // true     System.out.println( name.length()==0 ); // true    ```- ### Changing case:  - `.toLowerCase()` & `.toUpperCase()`,   - Ex:    ```java    String mix = \"Process FINISHED\";    System.out.println( mix.toUpperCase() ); // PROCESS FINISHED    System.out.println( mix.toLowerCase() ); // process finished    ```- ### Finding position:  - `.indexOf(text)`, `.lastIndexOf(text)`,   - Ex:    ```java     String msg = \"You are welcome\";     System.out.println( msg.indexOf('o') ); // 1 - first o     System.out.println( msg.indexOf('x') ); // -1     System.out.println( msg.indexOf(\"are\") ); // 4          System.out.println( msg.lastIndexOf('o') ); // 12    ```- ### Representing value into String:  - `String.valueOf(value)`,  - Ex:    ```java    // Representing value into String    String strInt = String.valueOf(1000);    System.out.println(strInt); // 1000    String strDou = String.valueOf(200.5d);    System.out.println(strDou); // 200.5    String strBoo = String.valueOf(true);    System.out.println(strBoo); // true    ```- ### Finding substring:  - `.substring(int beginIndex)`, `.substring(int beginIndex,int beforeThisIndex)`,  - Ex:    ```java    String total = \"Rahim Karim Tamim\";    String rahim = total.substring(0,5);    System.out.println(rahim); // Rahim    String karim = total.substring(6,11);    System.out.println(karim); // Karim    ```- ### Removing Leading and trailing spaces and control characters:  - `.trim()`,  - Ex:    ```java    String code = \" \\n hello pluto \\t \";    System.out.println( code.trim() ); // hello pluto    ```- ### Replacing part of string,  - `.replace(oldStr, new)`, `.replaceAll(regex,new)`,  - `.replace` takes (`CharSequence `, `CharSequence `) or (`char`, `char`), whereas `.replaceAll` takes (`regex`, `String`)  - I will discuss `regex` later insha'Allah in regex section.  - Ex:    ```java    String greeting = \"Hello old man, Hello\";    System.out.println( greeting.replace(\"Hello\",\"Hi\") ); // Hi old man, Hi    System.out.println( greeting.replaceAll(\"Hello\",\"Hi\") ); // Hi old man, Hi     ```- ### Matching start & end of a string;  - `.startsWith(str)`, `.endsWith(str)`,  - Ex:    ```java    String eq = \"20 + 22 = 42\";    System.out.println( eq.startsWith(\"2\")); // true    System.out.println( eq.endsWith(\"42\")); // true    ```- ### Splitting string:  - `.split(regex)`,  - Ex:    ```java     String strVowels = \"a,e,i,o,u\";     String[] vowels = strVowels.split(\",\"); //split(regex)    ```- ### Joining string:  - `String.join(sep, str1,str2.....)`,  - Ex:    ```java    String joined = String.join(\",\",\"A\",\"E\",\"I\",\"O\",\"U\"); // 1st one is separator    System.out.println(joined); // A,E,I,O,U    ```## String in switch statement- `switch` can't be null,- `case` must be string literal,- `case` can't be variable,- It is basically an `if-else` ladder,- Ex: See `testSwitchExpression()` in `Test.java`,  ```java  private static void testSwitchExpression(){                String status = \"on\";        switch (status){ // status mustn't be null          case \"on\":              System.out.println(\"on\"); //executed              break;          case \"off\": // check if status.equals(\"off\")              System.out.println(\"off\");              break;      }    }  ```## StringBuilder & StringBuffer- Similar like `String` but `mutable`,- Content can be changed without creating new object,- `StringBuffer` is `thread-safe`, but `StringBuilder` is not,- `StringBuffer` may be slower than `StringBuilder`,- Ex: See `stringBuilderTest()` in `Test.java`,  ```java  private static void stringBuilderTest(){        StringBuilder builder = new StringBuilder();      builder.append(\"This is builder-\").append(5).append(\". \");        String phone = \"0179210xxxx\";        builder.append(\"His phone number is: \").append(phone).append(\", Bg:\").append('O');        System.out.println(builder); // This is builder-5. His phone number is: 0179210xxxx, Bg:O        builder.insert(0,\"Hello, \");      System.out.println(builder); // Hello, This is builder-5. His phone number is: 0179210xxxx, Bg:O        builder.delete(0,7);      System.out.println(builder); // This is builder-5. His phone number is: 0179210xxxx, Bg:O        builder.reverse();      System.out.println(builder); // O:gB ,xxxx0129710 :si rebmun enohp siH .5-redliub si sihT        // palindrome check      String toCheck = \"Step on no pets\";        StringBuilder b1 = new StringBuilder(toCheck).reverse();      System.out.println(toCheck.equalsIgnoreCase(b1.toString())); // true  }  ```- All methods are same in `StringBuffer`. See `stringBufferTest()` in `Test.java`,## String concatenation- Can be concatenated using `+` operator,- Better to use `StringBuilder` or `StringBuffer` since multiple objects are not being created,- Ex: See `concatenateTest()` in `Test.java`,  ```java  private static void concatenateTest(){      int num = 5;        String total = \"This \";      total += \"is \";      total += String.valueOf(num);        System.out.println(total); // This is 5        // better approach since multiple objects are not created      StringBuilder builder = new StringBuilder();      builder.append(\"This \").append(\"is \").append(num);      System.out.println(builder); // This is 5  }  ```## Language-Sensitive String Comparison- For comparing strings based on the `dictionary order`,- Use `compare()` method of the `java.text.Collator` for this,- `compare()` in `java.text.Collator`:  - Returns `0` if equals,  - Returns `-1` if `1st` one comes before `2nd` one,  - Returns `1` if `1st` one comes after `2nd` one,- Ex: See `dictCompare()` in `Test.java`,  ```java  private static void dictCompare(){        String str1 = \"abc\";      String str2 = \"bcd\";      String str3 = \"Bcd\";        Collator collator = Collator.getInstance(Locale.US);        int res;        res = collator.compare(str1,str2);      System.out.println(res); // -1 since abc is before bcd        res = collator.compare(str2,str1);      System.out.println(res); // 1 since bcd is after abc        res = collator.compare(str2,str3);      System.out.println(res); // -1 since bcd is before Bcd  }  ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/string/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part1/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"string","subTopicName":"string","topic":{"topic_name":"string","no_of_sub_topics":2,"folder_name":"string","serial":7},"serial":2}},{"blogPK":{"topicName":"datetime","subTopicName":"datetime"},"content":"# DateTime - part1## Introduction- `Java 8` introduced a new `Date-Time API`,- Before this new API, there was `Legacy Date-Time API`,- `Legacy Date-Time API`:  - Includes classes like:    - `Date`,     - `Calendar`,     - `GregorianCalendar`  - Available in `java.util` and `java.sql` packages,  - Some issues with the legacy Date-Time API are:    - A `date` always had two components: `a date` and `a time`. No option for using one separately,    - Manipulating dates were complex,    - `Mutable` and therefore `not thread-safe`, ## `The New Date-Time API`:- `Correct`, `powerful`, and `extensible` Date-Time API,- It consists of about `80` classes,- `15` classes are enough for using effectively,- Has a separate set of classes to deal with `machine-based time` and `calendar-based human time`,- Lets you convert `machine-based time` to `human-based time` and vice versa,- Most `classes` are `immutable`,- Doesn't provide public `constructors`,- They allow creating object via `static factory methods` like,  - `of()`, `ofXxx()`, and `from()`,## Exploring the New Date-Time API- Contains large number of classes,- Naming convention of methods help understand the API tremendously,- Methods starting with the same prefix do the similar work,- All `classes`, `interfaces`, and `enums` for the `Date-Time API` are in `java.time` package,- Some frequently used classes of `java.time` package are:  - `LocalDate`: Only `Date`,  - `LocalTime`: Only `Time`,  - `LocalDateTime`: `Date` and `Time`,  - `ZonedDateTime`: `Date`, `Time` and `Zone`,  - `Period`: Deals with `years`, `months`, and `days` & their operation,  - `Duration`: Represents a period of time in terms of `seconds` and `nanoseconds`,  - `Instant`: Represents a `specific point` in time,- `4` of its subpackages are:  - `java.time.chrono`:    - Contains classes supporting `non-ISO calendar` systems like `Hijrah calendar`, `ThaiBuddhist calendar`,  - `java.time.format`:    - Contains classes for `formatting` and `parsing` `dates` and `times`,    - `java.time.temporal`:      - Contains classes for accessing `components of dates and times`,      - Also contains classes that act like `date-time adjusters`,    - `java.time.zone`:       - contains classes supporting time zones and zone rules- Ex: See `basicExample()` in `Test.java`: (Will be explained later),    ```java    private static void basicExample(){        LocalDate ld = LocalDate.of(2023, Month.MARCH,23);        System.out.println(ld); // 2023-03-23            LocalDate newDate = ld.plusDays(9);        System.out.println(newDate); // 2023-04-01            System.out.println( newDate.getDayOfWeek() ); // SATURDAY        System.out.println( newDate.getMonthValue() ); // 4    }    ```## The `ofXXX()` Methods- Allow creating object,- Ex:    ```java    LocalDate date1 = LocalDate.now();    System.out.println(date1); // 2023-08-16    LocalDate date2 = LocalDate.of(2023,4,23);    System.out.println(date2); // 2023-04-23    LocalDate date3 = LocalDate.ofEpochDay(1000); // epoch means time from Midnight January 1, 1970 UTC    System.out.println(date3); // 1972-09-27    LocalDate date4 = LocalDate.ofYearDay(2023,140);    System.out.println(date4); // 2023-05-20    ```## The `from()` Methods- A `static factory method`, similar to an `of()` method,- Create object from another `argument`. `argument` should have necessary value for converting,- Ex:    ```java    LocalDate date6 = LocalDate.now();    System.out.println(date6); // 2023-08-16    LocalDate date7 = LocalDate.from(date6);    System.out.println(date7); // 2023-08-16    LocalDateTime ldt = LocalDateTime.now();    System.out.println(ldt); // 2023-08-16T23:33:54.223464    LocalDate date8 = LocalDate.from(ldt);    System.out.println(date8); // 2023-08-16    ```    - Here `ldt` has `Date` component, so it can be used for creating `LocalDate` object,## The `withXXX()` Methods- Most classes in the Date-Time API are `immutable`,- For changing some field you need to use something like `withXXX`,- A `withXXX()` method `returns a copy` of an object with the `specified field changed`,- Ex:    ```java    LocalDate date9 = LocalDate.of(2023,Month.AUGUST,16);    LocalDate date10 = date9.withYear(2024);    System.out.println(date9); // 2023-08-16    System.out.println(date10);// 2024-08-16        LocalDate date11 = date9.withMonth(3);    System.out.println(date11); // 2023-03-16    ```## The `getXXX()` Methods- Returns the specified `component` of the object,- Ex:    ```java    LocalDate date = LocalDate.of(2023,Month.AUGUST,16);        System.out.println( date.getYear() ); // 2023        System.out.println( date.getMonth() ); // AUGUST    System.out.println( date.getMonthValue() ); // 8        System.out.println( date.getDayOfMonth() ); // 16    System.out.println( date.getDayOfWeek() ); // WEDNESDAY        System.out.println( date.get(ChronoField.DAY_OF_YEAR) ); // 228    ```## The `toXXX()` Methods- Converts an object to a related XXX type,- Ex:    ```java    LocalDateTime dateTime = LocalDateTime.of(2023,Month.AUGUST,16,23,10);    System.out.println(dateTime); // 2023-08-16T23:10        LocalDate date1 = dateTime.toLocalDate();    System.out.println(date1); // 2023-08-16        LocalTime time1 = dateTime.toLocalTime();    System.out.println(time1); // 23:10                System.out.println( date.toEpochDay() ); // 19585    ```## The `atXXX()` Methods- Lets you build a `new datetime object` from an `existing datetime object` by supplying `some additional` pieces of information,- `withXXX()` changes field and return same type of object. But- `atXXX()` may return different type by taking additional info,- Ex:    ```java    LocalDate date2 = LocalDate.of(2023,Month.AUGUST,16);    System.out.println(date2); // 2023-08-16        LocalDateTime dateTime2 = date2.atTime(23,10);    System.out.println(dateTime2); // 2023-08-16T23:10        ZonedDateTime zonedDateTime2 = dateTime2.atZone(ZoneOffset.UTC);    System.out.println(zonedDateTime2); // 2023-08-16T23:10Z    ```## The `plusXXX()` and `minusXXX()` Methods- Returns a copy after adding or subtracting a component value,- Ex:    ```java    LocalDate date3 = LocalDate.of(2023,Month.AUGUST,16);    System.out.println(date3); // 2023-08-16        LocalDate date4 = date3.plusDays(15);    System.out.println(date4); // 2023-08-31        LocalDate date5 = date3.plusMonths(35);    System.out.println(date5); // 2026-07-16    ```## The `multipliedBy()`, `dividedBy()`, `negated()` Methods- Don't make sense on `dates` and `times`,- Applicable to `Duration` and `Period`,- Ex:    ```java    Duration d = Duration.ofSeconds(200);    System.out.println(d); // PT3M20S <-- 3min 20sec        Duration d1 = d.multipliedBy(2);    System.out.println(d1); // PT6M40S        Duration d2 = d.dividedBy(4);    System.out.println(d2); // PT50S        Duration d3 = d.negated();    System.out.println(d3); // PT-3M-20S    ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/string/part2/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part2/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"datetime","subTopicName":"datetime","topic":{"topic_name":"datetime","no_of_sub_topics":6,"folder_name":"datetime","serial":8},"serial":1}},{"blogPK":{"topicName":"datetime","subTopicName":"datetime"},"content":"# DateTime - part2## Instants and Durations<img src=\"../files/duration_and_instant.jpg\" height=\"180px\">- `Epoch` is the reference point. which is `Midnight January 1, 1970 UTC`,- An `Instant` is a specific point,- `Duration` is range from `epoch`,- `nanosecond` precision is available,- `.toString()`:  - Returns `yyyy-MM-ddTHH:mm:ss.SSSSSSSSSZ` for `Instant`,  - Returns `PTnHnMnS` for `Duration`,- Used for recording `timestamps` and `elapsed time` `between two events`,- Can be compared to check which one is earlier,- Classes in the Date-Time API are `Serializable`,- Ex(`Instant`):  ```java  Instant instant = Instant.now();  Instant instant1 = Instant.ofEpochSecond(86420); //second    //----------------------epoch is 1970-01-01T00:00:00Z  System.out.println(instant1); // 1970-01-02T00:00:20Z    System.out.println( instant1.getEpochSecond() ); // 86420  System.out.println( instant1.get(ChronoField.MILLI_OF_SECOND) ); // 0  ```- Ex(`Duration`):  ```java  Duration duration = Duration.ofSeconds(86400);  System.out.println(duration); // PT24H   < ------ 24hours    Duration duration1 = Duration.ofDays(10).plusHours(12).plusMinutes(24).plusSeconds(48);  System.out.println(duration1); // PT252H24M48S <-- 252hours 24min 48sec    System.out.println( duration1.getSeconds() ); // 908688  System.out.println( duration1.get(ChronoUnit.NANOS) ); // 0  ```- Ex(compare):  ```java  Instant instant = Instant.ofEpochSecond(86420);  Instant instant1 = Instant.ofEpochSecond(86420*2);    System.out.println( instant.isBefore(instant1) ); // true  System.out.println( instant.isAfter(instant1) ); // false    Instant instant2 = Instant.ofEpochSecond(86420);  System.out.println( instant.equals(instant2) ); // true    Duration duration = Duration.ofSeconds(100);  Instant instant3 = instant2.plus(duration);  System.out.println(instant3); // 1970-01-02T00:02:00Z      Duration duration1 = Duration.ofDays(120);  Duration duration2 = duration1.plusDays(120);  System.out.println(duration2); // PT5760H  ```## The `ZoneOffset` Class- Represents a `fixed zone offset` from `UTC` time zone,- `ISO-8601 standards` support zone offsets between `-12:00 to +14:00`. But, - To avoid any problems in future if the zone offset gets extended, the `Date-Time API` supports zone offsets between `-18:00 to +18:00`,- Ex:  ```java  ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(\"Asia/Dhaka\"));  ZoneOffset zoneOffset = ZoneOffset.from(zdt);  System.out.println(zoneOffset); // +06:00    System.out.println(ZoneOffset.UTC); // Z  System.out.println(ZoneOffset.MIN); // -18:00  System.out.println(ZoneOffset.MAX); // +18:00  ```## The `ZoneId` Class- Represents a combination of a `zone offset` and the `rules for changing the zone offset`,- `ZoneId = ZoneOffset + ZoneRules`,- A time zone has a unique textual ID, which can be specified in `three formats`:  - `(1st)`Specified in terms of `zone offset`. It can be     - `Z` (`UTC 0`),    - `+hh:mm:ss`,    - `-hh:mm:ss`,    - For example: `+06:00`,  - `(2nd)`Zone ID is prefixed with `UTC`, `GMT`, or `UT` and followed by a `zone offset`,    - For example: `UTC+06:00`,  - `(3rd)`Zone ID is specified by using a `region`,     - For example, `Asia/Dhaka`,- Ex:  ```java  ZoneId zoneId = ZoneId.of(\"+06:00\");  System.out.println(zoneId); // +06:00  ZonedDateTime zonedDateTime = ZonedDateTime.now(zoneId);  System.out.println(zonedDateTime); // 2023-08-17T11:44:59.644430500+06:00 <---- See +06:00    ZoneId zoneId1 = ZoneId.of(\"UTC+06:00\");  System.out.println(zoneId1); // UTC+06:00  ZonedDateTime zonedDateTime1 = ZonedDateTime.now(zoneId1);  System.out.println(zonedDateTime1); // 2023-08-17T11:46:04.027586300+06:00[UTC+06:00] <---- See +06:00    ZoneId zoneId2 = ZoneId.of(\"Asia/Dhaka\");  System.out.println(zoneId2); // Asia/Dhaka  ZonedDateTime zonedDateTime2 = ZonedDateTime.now(zoneId2);  System.out.println(zonedDateTime2); // 2023-08-17T11:46:04.027586300+06:00[Asia/Dhaka] <---- See +06:00  ```## Human scale date time components<img src=\"../files/human_scale_date_time.jpg\" height=\"300px\">## Useful Datetime-Related `Enums`Some `enums` representing `constants` for date and time components are:- ### Month  - Contains `12` constants to represents the `12` months of the year,  - Ex:    ```java    System.out.println( EnumSet.allOf(Month.class) );    // [JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER]    LocalDate localDate = LocalDate.of(2023, Month.MARCH, 11);    System.out.println(localDate); // 2023-03-11    ```- ### DayOfWeek  - `7` constants to represent `seven days` of the week,  - Ex:    ```java    System.out.println(EnumSet.allOf(DayOfWeek.class));    // [MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]    LocalDate localDate = LocalDate.of(2023, Month.MARCH, 1);    System.out.println(localDate.getDayOfWeek()); // WEDNESDAY    ```- ### ChronoField  - The `ChronoField` enum contains a long list of constants, They are    ```    [NanoOfSecond, NanoOfDay, MicroOfSecond, MicroOfDay, MilliOfSecond, MilliOfDay, SecondOfMinute, SecondOfDay, MinuteOfHour, MinuteOfDay, HourOfAmPm, ClockHourOfAmPm, HourOfDay, ClockHourOfDay, AmPmOfDay, DayOfWeek, AlignedDayOfWeekInMonth, AlignedDayOfWeekInYear, DayOfMonth, DayOfYear, EpochDay, AlignedWeekOfMonth, AlignedWeekOfYear, MonthOfYear, ProlepticMonth, YearOfEra, Year, Era, InstantSeconds, OffsetSeconds]    ```  - Ex:    ```java    LocalDate localDate = LocalDate.of(2023, Month.MARCH, 11);    System.out.println( localDate.get(ChronoField.YEAR) ); // 2023    System.out.println( localDate.get(ChronoField.MONTH_OF_YEAR) ); // 3    System.out.println( localDate.get(ChronoField.DAY_OF_MONTH) ); // 11    System.out.println( localDate.get(ChronoField.DAY_OF_YEAR) ); // 70    System.out.println( localDate.get(ChronoField.YEAR_OF_ERA) ); // 2023    ```- ### ChronoUnit  - All constants are:    ```    [Nanos, Micros, Millis, Seconds, Minutes, Hours, HalfDays, Days, Weeks, Months, Years, Decades, Centuries, Millennia, Eras, Forever]    ```  - Ex:    ```java    LocalDate date = LocalDate.of(2023, Month.MARCH, 11);    System.out.println(date); // 2023-03-11      LocalDate date1 = date.plus(10,ChronoUnit.DAYS);    System.out.println(date1); // 2023-03-21      LocalDate date2 = date.plus(12,ChronoUnit.YEARS);    System.out.println(date2); // 2035-03-11      LocalDate date3 = date.plus(2,ChronoUnit.DECADES);    System.out.println(date3); // 2043-03-11    ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part3/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"datetime","subTopicName":"datetime","topic":{"topic_name":"datetime","no_of_sub_topics":6,"folder_name":"datetime","serial":8},"serial":2}},{"blogPK":{"topicName":"datetime","subTopicName":"datetime"},"content":"# DateTime - part3## `LocalDate`, `LocalTime`, and `LocalDateTime`- `LocalDate`:  - Represent `Date` without `time` and `zone`,- `LocalTime`:  - Represent `Time` without `date` and `zone`,- `LocalDateTime`:  - Represent `Date` & `Time` without `zone`,- Ex: See `dateTimeDateTime()` in `Test.java`,    ```java    LocalDate date = LocalDate.of(2023, Month.MARCH, 23);    System.out.println( date ); // 2023-03-23        LocalDate date1 = date.plusDays(20);    System.out.println( date1 ); // 2023-04-12        LocalTime time = LocalTime.of(11,12,13);    System.out.println( time ); // 11:12:13        LocalTime time1 = time.plusHours(14);    System.out.println(time1); // 01:12:13        LocalDateTime dateTime = LocalDateTime.of(2023,Month.MARCH,23,11,12,13);    System.out.println( dateTime ); // 2023-03-23T11:12:13        LocalDateTime dateTime1 = dateTime.plusMonths(23);    System.out.println( dateTime1 ); // 2025-02-23T11:12:13        LocalDate date2 = LocalDate.from(dateTime1); // dateTime has date component    System.out.println( date2 );        LocalTime time2 = LocalTime.from(dateTime1); // dateTime has time component    System.out.println( time2 );    ```## `OffsetTime` and `OffsetDatetime`- Represents a `time` and a `datetime` respectively with a `zone offset` from `UTC`,- `OffsetTime` can be converted into `LocalTime`. Since,  ```  OffsetTime = LocalTime + ZoneOffset  ```- `OffsetDateTime` can be converted into `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`. Since,  ```  OffsetDateTime = LocalDateTime + ZoneOffset  ```- Ex: See `zoneTimeDateTime()` in `Test.java`,    ```java    ZoneOffset zone = ZoneOffset.of(\"+06:00\");    OffsetTime time = OffsetTime.of(11,12,13,0,zone);    System.out.println( time ); // 11:12:13+06:00    LocalTime localTime = time.toLocalTime(); // to localTime    System.out.println( localTime ); // 11:12:13      OffsetDateTime offsetDateTime = OffsetDateTime.of(2023,3,23,11,12,13,0,zone);    System.out.println( offsetDateTime ); // 2023-03-23T11:12:13+06:00    LocalDateTime localDateTime = offsetDateTime.toLocalDateTime(); // to LocalDateTime    System.out.println( localDateTime ); // 2023-03-23T11:12:13    LocalDate localDate = offsetDateTime.toLocalDate(); // to LocalDate    System.out.println( localDate ); // 2023-03-23    LocalTime localTime1 = offsetDateTime.toLocalTime(); // to LocalTime    System.out.println( localTime1 ); // 11:12:13    OffsetDateTime offsetDateTime1 = OffsetDateTime.of(2023,3,23,11,12,13,0,zone);    System.out.println( offsetDateTime1 ); // 2023-03-23T11:12:13+06:00    Instant instant = offsetDateTime1.toInstant(); // UTC so, 6 is subtracted    System.out.println( instant ); // 2023-03-23T05:12:13Z    ```## `ZonedDatetime`- Represents a `datetime` with time `zone`,    ```    ZonedDateTime = LocalDateTime + ZoneId    ```- Ex: See `testZonedDateTime()` in `Test.java`,    ```java    ZoneId zoneId = ZoneId.of(\"+06:00\");        ZonedDateTime zdt = ZonedDateTime.of(2023,3,21,11,12,12,0,zoneId);    System.out.println( zdt ); // 2023-03-21T11:12:12+06:00        ZoneOffset offset = zdt.getOffset();    System.out.println( offset ); // +06:00        ZoneId id = zdt.getZone();    System.out.println( id ); // +06:00        LocalDate localDate = zdt.toLocalDate();    System.out.println( localDate ); // 2023-03-21        LocalTime localTime = zdt.toLocalTime();    System.out.println( localTime ); // 11:12:12        OffsetDateTime offsetTime = zdt.toOffsetDateTime();    System.out.println( offsetTime ); // 2023-03-21T11:12:12+06:00                LocalDateTime localDateTime = zdt.toLocalDateTime();    System.out.println( localDateTime ); // 2023-03-21T11:12:12    ```## Same Instant, Different Times- Can `Instant` can have different time because of different `zone`,- Ex: See `zoneConversion()` in `Test.java`,    ```java    LocalDateTime ldt = LocalDateTime.of(2023, Month.MARCH, 14, 17, 30);    ZoneId zoneSaudi = ZoneId.of(\"Asia/Riyadh\");        ZonedDateTime zdt = ZonedDateTime.of(ldt, zoneSaudi); // <-----------(1)    System.out.println( zdt ); // 2023-03-14T17:30+03:00[Asia/Riyadh]        ZoneId zoneDhaka = ZoneId.of(\"Asia/Dhaka\");    ZonedDateTime zdt2 = zdt.withZoneSameInstant(zoneDhaka); // <--------(2)    System.out.println( zdt2 ); // 2023-03-14T20:30+06:00[Asia/Dhaka]        ZonedDateTime zdt3 = zdt.withZoneSameInstant(ZoneId.of(\"Z\")); // utc    System.out.println( zdt3 ); // 2023-03-14T14:30Z    ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part2/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part4/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"datetime","subTopicName":"datetime","topic":{"topic_name":"datetime","no_of_sub_topics":6,"folder_name":"datetime","serial":8},"serial":3}},{"blogPK":{"topicName":"datetime","subTopicName":"datetime"},"content":"# DateTime - part4## Clocks- Provides access to the current `instant`, `date`, and `time` in a time `zone`,- You can extend the `Clock` class to implement your own clock,- Ex: See `testClock()` in `Test.java`,    ```java    Clock clock = Clock.systemDefaultZone();    Clock clock1 = Clock.system(ZoneId.of(\"+06:00\"));         System.out.println( clock.getZone() ); // Asia/Dhaka    System.out.println( clock.instant() ); // 2023-08-17T09:10:14.911558100Z <---- UTC    System.out.println( clock.millis() ); // 1692263414911            LocalDateTime ldt = LocalDateTime.now(clock);    System.out.println( ldt ); // 2023-08-17T15:10:14.911558100 <----- system time    ```## Period & Duration- Amount of time in terms of calendar fields `years`, `months`, and `days`. Whereas `Duration` is also an amount of time in terms of `seconds` and `nanoseconds`,- `Negative periods` are supported,- `Duration` represents an `exact number of nanoseconds`, whereas `Period` represents an `inexact amount of time`,- `Period` is for `humans` what a `Duration` is for `machines`,- For example: `2 months` is a period since this is not exact. It can be `59`,`60`,`61` days,- `Additions`, `subtractions`, `multiplications`, and `negation` can be performed on a period,- Object is created using `static factory method`,- When you add a `period of one day` to a `ZonedDateTime`, the `date component` changes to the `next day`, keeping the `time the same`. But,- When you add a `duration of a day`, it will always add `24 hours`,- `normalized()` method of the `Period` class to normalize the `years` and `months` only,- Ex(`Period`): See `testPeriod()` in `Test.java`,  ```java  private static void testPeriod(){        Period period;      period = Period.of(1,1,1);      System.out.println( period ); // P1Y1M1D <--- 1year 1month 1day        period = Period.ofDays(10);      System.out.println( period ); // P10D <--- 10days        period = period.negated();      System.out.println( period ); // P-10D        period = period.negated();      System.out.println( period ); // P10D        period = period.plusMonths(16);      System.out.println( period ); // P16M10D        period = period.minusMonths(4);      System.out.println( period ); // P12M10D        period = period.multipliedBy(2);      System.out.println( period ); // P24M20D        period = period.normalized();      System.out.println( period ); // P2Y20D <-- only year & month are normalized    }  ```- Ex(`Duration`): See `testDuration()` in `Test.java`,  ```java  private static void testDuration(){        Duration duration;      duration = Duration.ofDays(10);      System.out.println( duration ); // PT240H        duration = duration.negated();      System.out.println( duration ); // PT-240H        duration = duration.negated();      System.out.println( duration ); // PT-240H        duration = duration.plusMinutes(160);      System.out.println( duration ); // PT242H40M        duration = duration.minusMinutes(20);      System.out.println( duration ); // PT242H20M        duration = duration.multipliedBy(2);      System.out.println( duration ); // PT484H40M  }  ```## Period Between Two Dates and Times- For computing amount of time elapsed between two `dates`, `times`, and `datetime`,- There are two ways:  - `between()` method on one of the constants in the `ChronoUnit` enum,    - Returns the amount of time elapsed from the `first` argument to the `second` argument,    - Will return `negative` is `2nd` argument is before `1st`,  - `until()` method on one of the datetime-related classes,- It isn't always possible to compute the amount of time elapsed between two dates and times. For example:  - `Hours` between a `LocalDate` and a `LocalDateTime` not possible, since `LocalDate` doesn't have `hours`,   - If such parameters are passed to the methods, a `runtime exception` is thrown,- For calculating, specified `end date/time` should be `convertible` to the start `date/time`,- Ex: See `calculateElapsed()` in `Test.java`,  ```java  private static void calculateElapsed(){        LocalTime t1 = LocalTime.of(7,12);      LocalTime t2 = LocalTime.of(11,12);        long hours = t1.until(t2, ChronoUnit.HOURS);      System.out.println( hours ); // 4        long hrs = ChronoUnit.HOURS.between(t1,t2);      System.out.println( hrs ); // 4    }  ```## Partials- A partial is a `date`, `time`, or `datetime` that doesn't fully specify an `instant` on a timeline,- Makes sense to `humans`,- `LocalDate`, `LocalTime`, `LocalDateTime`, and `OffsetTime` are examples of `partials` since they can't be converted to `Instant`. But,- `OffsetDateTime` and `ZonedDateTime` aren't partials. Since they can be converted into `Instant` without providing extra info,- We have some other partials like for expressing Birthday(Has only Day & Month),- `3` more partials are:  - `Year`:    - Represent only year,  - `YearMonth`:    - Represent `Year` and `Month` both,  - `MonthDay`:    - Represent `Month` and `Day`,- Ex: See `calculateDayName()` in `Test.java`,  ```java  private static void calculateDayName(){      MonthDay spDate = MonthDay.of(Month.AUGUST,17);        Year year = Year.of(2023);        for(int i=0; i<5; i++){            LocalDate date = year.plusYears(i).atMonthDay(spDate);            String strDate = date.toString();          String dayName = date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.US);          System.out.println(strDate+\" -> \"+dayName);      }  }  ```  Output:  ```text  2023-08-17 -> Thursday  2024-08-17 -> Saturday  2025-08-17 -> Sunday  2026-08-17 -> Monday  2027-08-17 -> Tuesday  ```### Temporal = Something related to date and time## Adjusting Dates- Sometimes we need to find date of `first Monday of the month`, `the next Tuesday` etc,- Can be done using `TemporalAdjuster` interface,- Ex:  ```java  LocalDate localDate = LocalDate.of(2023,Month.AUGUST,17);    LocalDate localDate1 = localDate.with(TemporalAdjusters.next(DayOfWeek.SATURDAY));  System.out.println(localDate1); // 2023-08-19    LocalDate localDate2 = localDate.with(TemporalAdjusters.nextOrSame(DayOfWeek.THURSDAY));  System.out.println(localDate2); // 2023-08-17    LocalDate localDate3 = localDate.with(TemporalAdjusters.next(DayOfWeek.THURSDAY));  System.out.println(localDate3); // 2023-08-24    LocalDate localDate4 = localDate3.with(TemporalAdjusters.lastDayOfMonth());  System.out.println(localDate4); // 2023-08-31  ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part3/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part5/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"datetime","subTopicName":"datetime","topic":{"topic_name":"datetime","no_of_sub_topics":6,"folder_name":"datetime","serial":8},"serial":4}},{"blogPK":{"topicName":"datetime","subTopicName":"datetime"},"content":"# DateTime - part5## Formatting Dates and Times- Representing a `datetime` object in a `user-defined textual form`,- The most important point to keep in mind is that `formatting` and `parsing` are always performed by an object of the `DateTimeFormatter` class,- `Parsing` is the `opposite of formatting`,- To format a `datetime object`, `a formatter` needs `2` pieces of information:  - A format `pattern`, and   - A `locale`,- Formatting can be performed in several ways. They all use `a DateTimeFormatter object` directly or indirectly,- Some ways are:  - Using `pre-defined` `standard datetime formatters`,  - Using the `format()` method of the `datetime classes`,  - Using `user-defined patterns`,  - Using the `DateTimeFormatterBuilder class`,## Using `pre-defined` `standard datetime formatters`,- Most of the formatters use `ISO datetime formats`,- Ex:    ```java    LocalDate date = LocalDate.of(2023, Month.AUGUST,17);    String strDate;          strDate = DateTimeFormatter.ISO_DATE.format(date);    System.out.println( strDate ); // 2023-08-17          strDate = DateTimeFormatter.ISO_WEEK_DATE.format(date);    System.out.println( strDate ); // 2023-W33-4 <----- 33 weeks 4 days          //strDate = DateTimeFormatter.ISO_TIME.format(date); // Runtime error. since date doesn't have time component          LocalTime time = LocalTime.of(11,12,13);    String strTime = DateTimeFormatter.ISO_TIME.format(time);          System.out.println( strTime ); // 11:12:13    ```## Using the `format()` method of the `datetime classes`- Done using `format()` method on `datetime` related class,- `format()` method take an object of the `DateTimeFormatter` class,- Ex:    ```java    LocalDate date = LocalDate.of(2023, Month.AUGUST,17);    String strDate;        strDate = date.format(DateTimeFormatter.ISO_DATE);    System.out.println(strDate); // 2023-08-17        strDate = date.format(DateTimeFormatter.ISO_WEEK_DATE);    System.out.println(strDate); // 2023-W33-4        LocalTime time = LocalTime.of(11,12,13);    String strTime = time.format(DateTimeFormatter.ISO_TIME);    System.out.println(strTime); // 11:12:13    ```## Using user-defined patterns- Most commonly used methods in the `DateTimeFormatter` class is the `ofPattern()` method,- `ofPattern()`:  - Takes `pattern` and `locale`(optional),  - Returns a `DateTimeFormatter object` with the `specified pattern and locale`,- Here formatting is performed based on a `pattern`,  - A `pattern` is a sequence of characters that have `special meanings`,- Some widely used special characters are:    <table>        <tr> <th>Symbol</th> <th>Description</th> <th>Example</th> </tr>        <tr>     <th>y</th> <th>Year of era.<br>Always positive for AD & BC</th>      <th>      <table>        <tr> <th>yy</th> <th>23</th> </tr>        <tr> <th>yyyy</th> <th>2023</th> </tr>        <tr> <th>yyyyy</th> <th>02023</th> </tr>      </table>    </tr>        <tr>     <th>D</th> <th>Day of year (1 -366)</th>      <th>      <table>        <tr> <th>D</th> <th>150</th> </tr>      </table>    </tr>        <tr>     <th>M</th> <th>Month of year</th>      <th>        <table>        <tr> <th>M</th> <th>5</th> </tr>        <tr> <th>MM</th> <th>05</th> </tr>        <tr> <th>MMM</th> <th>Jul</th> </tr>        <tr> <th>MMMM</th> <th>July</th> </tr>       </table>     </th>    </tr>        <tr>     <th>d</th> <th>Day of month</th>      <th>        <table>        <tr> <th>d</th> <th>23</th> </tr>       </table>     </th>    </tr>        <tr>     <th>W</th> <th>Week of month</th>      <th>        <table>        <tr> <th>W</th> <th>5</th> </tr>       </table>     </th>    </tr>        <tr>     <th>E</th> <th>Day of week</th>      <th>        <table>        <tr> <th>E</th> <th>7</th> </tr>        <tr> <th>EE</th> <th>07</th> </tr>        <tr> <th>EEE</th> <th>Sun</th> </tr>        <tr> <th>EEEEE</th> <th>Sunday</th> </tr>       </table>     </th>    </tr>        <tr>     <th>a</th> <th>AM/PM of day</th>      <th>        <table>        <tr> <th>a</th> <th>AM</th> </tr>        <tr> <th>a</th> <th>PM</th> </tr>       </table>     </th>    </tr>        <tr>     <th>h</th> <th>Clock hour of AM/PM (1-12)</th>      <th>        <table>        <tr> <th>h</th> <th>5</th> </tr>       </table>     </th>    </tr>        <tr>     <th>k</th> <th>Clock hour of AM/PM (1-24)</th>      <th>        <table>        <tr> <th>k</th> <th>9</th> </tr>       </table>     </th>    </tr>        <tr>     <th>H</th> <th>Hour of day (0-23)</th>      <th>        <table>        <tr> <th>H</th> <th>7</th> </tr>        <tr> <th>HH</th> <th>07</th> </tr>       </table>     </th>    </tr>        <tr>     <th>m</th> <th>Minute of hour</th>      <th>        <table>        <tr> <th>mm</th> <th>30</th> </tr>       </table>     </th>    </tr>        <tr>     <th>s</th> <th>Second of minute</th>      <th>        <table>        <tr> <th>ss</th> <th>12</th> </tr>       </table>     </th>    </tr>        <tr>     <th>V</th> <th>Time zone ID</th>      <th>        <table>        <tr> <th>VV</th> <th>America/Chicago</th> </tr>       </table>     </th>    </tr>        <tr>     <th>Z</th> <th>Zone offset</th>      <th>        <table>        <tr> <th>Z</th> <th>-0500</th> </tr>        <tr> <th>ZZ</th> <th>-0500</th> </tr>        <tr> <th>ZZZ</th> <th>-05:00</th> </tr>        <tr> <th>ZZZZ</th> <th>GMT-05:00</th> </tr>       </table>     </th>    </tr>        <tr>     <th>'</th> <th>Escape for text<br>Text within single quotes is output directly</th>      <th>        <table>        <tr> <th>'Hello'</th> <th>Hello</th> </tr>        <tr> <th>'Hello' MMMM</th> <th>Hello July</th> </tr>       </table>     </th>    </tr>        <tr>     <th>''</th> <th>A single quote</th>      <th>        <table>        <tr> <th>'''Hello''' MMMM</th> <th>'Hello' July</th> </tr>       </table>     </th>    </tr>        </table>- Ex:    ```java    LocalDate date = LocalDate.of(2023, Month.AUGUST,17);        String pattern = \"ddMMM yy\";    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);        String strDate = formatter.format(date);    System.out.println(strDate); // 17Aug 23            LocalDateTime ldt = LocalDateTime.of(2023,Month.AUGUST,17,19,16);        String fullPattern = \"ddMM yy 'at' hh:mm:ssa\";    DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern(fullPattern);        String formatted = formatter1.format(ldt);    System.out.println(formatted); // 1708 23 at 07:16:00PM    ```## Using the DateTimeFormatterBuilder class- Previous one is enough for all cases,- Ex:    ```java    DateTimeFormatter formatter = new DateTimeFormatterBuilder()            .appendLiteral(\"My birthday in \")            .appendValue(ChronoField.YEAR)            .appendLiteral(\" is not on \")            .appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL_STANDALONE)            .toFormatter();        LocalDate ld = LocalDate.of(2023, Month.MARCH, 22);    String str = ld.format(formatter);    System.out.println(str); // My birthday in 2023 is not on Wednesday    ```## Using Locale Specific Formats- Uses predefined format for which is locale specific,- Ex:    ```java    LocalDate ld = LocalDate.of(2023, Month.AUGUST, 17);        DateTimeFormatter fmt = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);    System.out.println( fmt.format(ld) ); // 8/17/23            LocalTime localTime = LocalTime.of(11,12,13);        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM);    System.out.println( formatter.format(localTime) );            LocalDateTime ldt = LocalDateTime.of(ld,localTime);        ZonedDateTime zdt = ldt.atZone(ZoneId.of(\"+06:00\"));        DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL);    System.out.println( formatter1.format(zdt) ); // Thursday, August 17, 2023 at 11:12:13 AM +06:00    ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part4/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part6/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"datetime","subTopicName":"datetime","topic":{"topic_name":"datetime","no_of_sub_topics":6,"folder_name":"datetime","serial":8},"serial":5}},{"blogPK":{"topicName":"datetime","subTopicName":"datetime"},"content":"# DateTime - part6## Parsing Dates and Times- Process of creating a `date`, `time`, or `datetime` object from a `string`,- `2` ways to parse:  - Using the `parse()` method of the `datetime` class,  - Using the `parse()` method of the `DateTimeFormatter` class,- A `DateTimeParseException` is thrown if the text can't be parsed,- `getErrorIndex()` method returns the `index` in the text where the error occurred,- `getParsedString()` method returns the text being parsed,- Ex(using `datetime` `parse()`):    ```java    String strDate = \"2023-08-17\";        LocalDate localDate = LocalDate.parse(strDate);    System.out.println(localDate); // 2023-08-17        strDate = \"2023-W33-4\"; // this format is discussed in previous section    LocalDate localDate1 = LocalDate.parse(strDate,DateTimeFormatter.ISO_WEEK_DATE);    System.out.println(localDate1); // 2023-08-17    ```- Ex(Using `DateTimeFormatter` `parse()`):    ```java    String pattern = \"yyyy-MM-dd\";    String strDate = \"2023-08-17\";        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern, Locale.US);    TemporalAccessor ta = formatter.parse(strDate);        LocalDate localDate = LocalDate.from(ta);    System.out.println(localDate); // 2023-08-17        String pattern1 = \"dd/MM/yyyy\";    String strDate1 = \"17/08/2023\";        DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern(pattern1);    TemporalAccessor ta1 = formatter1.parse(strDate1);        LocalDate localDate1 = LocalDate.from(ta1);    System.out.println(localDate1); // 2023-08-17                    ```>> Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. (Martin Golding)<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part5/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/formatter/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"datetime","subTopicName":"datetime","topic":{"topic_name":"datetime","no_of_sub_topics":6,"folder_name":"datetime","serial":8},"serial":6}},{"blogPK":{"topicName":"formatter","subTopicName":"formatter"},"content":"# Formatter## Formatting Numbers- Two classes can be used to format and parse numbers,  - `java.text.NumberFormat`:    - Used to format a number in a particular `locale`’s predefined format,   - `java.text.DecimalFormat`:    - Used to format a number in a format `of your choice` in a particular `locale`,    - Provides advanced formatting,- Ex(`NumberFormat`): see `numberFormat()` in `Test.java`,    ```java    private static void numberFormat(){            //------------   default locale USA -----------        NumberFormat format = NumberFormat.getNumberInstance();            double num = 175570;        String sn = format.format(num);        System.out.println(sn); // 175,570            NumberFormat format1 = NumberFormat.getCurrencyInstance();            double num1 = 175570;        String st = format1.format(num1);        System.out.println(st); // $175,570.00            //-------------------   BD locale --------------        NumberFormat format2 = NumberFormat.getNumberInstance(new Locale(\"en\",\"BD\"));            double num2 = 175570;        sn = format2.format(num2);        System.out.println(sn); // 175,570            NumberFormat format3 = NumberFormat.getCurrencyInstance(new Locale(\"en\",\"bd\"));        st = format3.format(num);        System.out.println(st); // BDT175,570.00    }    ```- Ex(`DecimalFormat`): see `decimalFormat()` in `Test.java`,    ```java    private static void decimalFormat(){        double num = 175.570354;            String pattern = \"####.####\"; // my custom pattern        DecimalFormat format = new DecimalFormat();        format.applyPattern(pattern); // applying my pattern            String sn = format.format(num);        System.out.println(sn); // 175.5704            pattern = \"0000.0000\";        format.applyPattern(pattern);          sn = format.format(num);        System.out.println(sn); // 0175.5704              num = -125.53;        pattern = \"#.##\";        format.applyPattern(pattern);            sn = format.format(num);        System.out.println(sn);// -125.53              num = 12.53;        pattern = \"#.##;(#.##)\"; // left part of semicolon is for positive number, right part for negative number        format.applyPattern(pattern);        sn = format.format(num); System.out.println(sn); // 12.53            num = -12.53;        sn = format.format(num); System.out.println(sn); // (12:53)    }    ```## Printf-style Formatting- `java.util.Formatter` class supports `printf-style` formatting,- Similar to `printf()` in `C`,- Ex: See `printfStyleFormatting()` in `Test.java`,  ```java  private static void printfStyleFormatting(){      // Formatting strings      System.out.printf(\"%1$4s, %2$4s, and %3$6s %n\", \"Fu\", \"Hu\", \"Lo\"); //  Fu,   Hu, and     Lo        //formatting numbers      //takes space on left side      System.out.printf(\"%1$4d, %2$4d, %3$4d %n\", 10, 100, 1000); //  10,  100, 1000        //takes space on right side      System.out.printf(\"%1$-4d, %2$-4d, %3$-4d %n\", 1, 10, 100); //1   , 10  , 100  }  ```- `%1$4s`:  - `1` means it will use the first string provided by user. `\"Fu\"` for `1st` `println()`,  - `4` means total `4` character will be taken.    - Space will be added on left(`4`),    - Space will be added on right( if negative is used),  - `s` means `String`,  >> It's disturbing. Learn yourself if you want more. Not really useful.<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/datetime/part6/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/regex/part1/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"formatter","subTopicName":"formatter","topic":{"topic_name":"formatter","no_of_sub_topics":1,"folder_name":"formatter","serial":9},"serial":0}},{"blogPK":{"topicName":"regex","subTopicName":"regex"},"content":"# Regex - part1<p align=\"center\">    <img src=\"../files/regex_intro.jpg\" height=\"300px\" alt=\"from nixCraft facebook\"></p>## Introduction- A way to describe a `pattern` in a sequence of characters,- The pattern may be used   - To validate the sequence of characters,   - To search through the sequence of characters,   - To replace the sequence of characters etc- For example: We may validate user given email address using it;- For validating a pattern, We need  - To recognize the pattern,  - A way(`Regular expression`) to express the recognized pattern,  - A program(`Regular expression engine`) that can match the pattern against the input string,- Characters that have `special meanings` inside a regular expression are called `metacharacters`,## Some symbols for pattern- `[ `, `]` are used to specify a `character class`(set of characters) inside a regular expression,- Range of characters can be specified using a character class. The range is expressed using a hyphen (`-`),- If you use `^` in the beginning of a `character class`, it means `complement` (meaning not),- Some examples:  - `[abc]`:    - Pattern can have only one character among `a`,`b`,`c`,    - Ex: `a`, `c` are valid string,  - `[A-Z]`:    - Pattern can have only one character between `A` to `Z`,    - Ex: `A`, `R`, `S` are valid string,  - `[^A-Z]`:    - Pattern can have only one character except `A` to `Z`,    - Ex: `a`, `t`, `4` are valid string,  - `[a-cx-z]`:    - Any character from `a,b,c,x,y,z`,  - `[0-9&&[4-8]]`:    - Intersection of `[0-9]` and `[4-8]`,     - Any character from `4,5,6,7,8`,## Predefined character class- `\\d`:  - A digit,  - Same as `[0-9]`,  - Ex: `0`,`1,`- `\\D`:  - A non-digit,  - Same as `[^0-9]`,  - Ex: `a`, `P`,- `\\s`:  - A `whitespace` character,  - Same as `[ \\t\\n\\x0B\\f\\r]`,  - Includes:    - A space(` `). See first one before `\\t`,    - A tab(`\\t`),    - A new line(`\\n`),    - A vertical tab(`\\x0B`),     - A form feed(`\\f`),     - A carriage return (`\\r`),  - Ex: ` `(space),- `\\S`:  - A `non-whitespace` character,  - Same as `[^\\s]`,  - Ex: `S`,`U`,- `\\w`:  - A word character,  - Same as `[a-zA-Z_0-9]`,  - Includes:    - lowercase letters,    - uppercase letter,     - underscore,    - decimal digits,  - Ex: `N`,`D`,- `\\W`:  - A non-word character,  - Same as `[^\\w]`,  - Ex: `@`,`+`,## Ex-1 (Basic): See `basicRegex()` in `Test.java`,- Everything will be explained later,   ```java    private static void basicRegex(){            String regex = \"[ABO][+-]\";        Pattern pattern = Pattern.compile(regex);            String[] arr = {\"A+\",\"AB-\",\"B-\",\"O\"};            for(String bg : arr) {            Matcher matcher = pattern.matcher(bg);                if(matcher.matches()){ System.out.println(bg+\" passed\"); }            else{ System.out.println(bg+\" failed\"); }        }        }    ```- Output:    ```    A+ passed    AB- failed    B- passed    O failed    ```## More Powers to Regular Expressions- `java.util.regex` contains three classes to support the full version of regular expressions,- `3` classes are:  - `Pattern`,    - Holds the compiled form of a regular expression,    - Compiled form facilitate faster string matching,  - `Matcher`,    - Associates the string to be matched with a `Pattern`,    - It performs the actual match,  - `PatternSyntaxException`,    - Represents an `error` in a malformed regular expression,**RE = Regular Expression**## Steps for using RE- Find regex and compile using `Pattern` class,- Create a `Matcher` object from `Pattern` object for matching operation,- Perform required operations on `Matcher` object,## Compiling Regular Expressions (`Pattern`)- A `Pattern` holds the `compiled form` of a RE,- It(`Pattern`) is `immutable`,- It can be shared,- It has no public `constructor`,- `Pattern` class contains a `static compile()` method, which returns a `Pattern object`,- Two overloaded version of `compile()` method in `Pattern` class:  - `static Pattern compile(String regex)`,  - `static Pattern compile(String regex, int flags)`- Ex:    ```java    String regex = \"[ABO][+-]\";    Pattern pattern = Pattern.compile(regex);    Pattern pattern1 = Pattern.compile(regex,Pattern.CASE_INSENSITIVE);    ```## Creating a `Matcher`:- Used to `perform a match` on a sequence of characters by interpreting the compiled pattern held in a `Pattern object`,- It(`Matcher`) has no `public constructor`,- `matcher()` method of the `Pattern` class is used to get an instance of the `Matcher` class,- Ex:    ```java    String regex = \"[ABO][+-]\";    Pattern pattern = Pattern.compile(regex);                String input = \"O+\";    Matcher matcher = pattern.matcher(input);    ```  ## Matching the Pattern- Following methods are available for matching:  - `find()`:    - Used to find a `match` for the `pattern` in the `input`,    - If the find succeeds, it returns `true`, else `false`,    - `first call` to this method starts the search for the `pattern` at the `beginning` of the input,    - If the previous call to this method was successful, the `next call` to this method starts the search after the `previous match`,  - `start()`:    - Returns the `start index` of the `previous match`,     - It is used after a successful `find()` method call,  - `end()`:    - Returns the `index` of the `last character` in the matched string `plus one`,    - So, `end() - start()` gives you the matched string of user input,  - `group()`:    - Returns the found `string` by the previous successful `find()` method call,- Ex: See `performRegexOperation1()` in `Test.java`,    ```java    private static void performRegexOperation1(){            String regex = \"[ABO][+-]\";        Pattern pattern = Pattern.compile(regex);            String input = \"O+A+B+O-MNB-\"; // <------ input to find pattern        Matcher matcher = pattern.matcher(input);            while (matcher.find()){            String bg = matcher.group(); // or            String sameBg = input.substring(matcher.start(), matcher.end());                System.out.println(bg+\" = \"+sameBg);        }    }    ```    ```    Output    O+ = O+    A+ = A+    B+ = B+    O- = O-    B- = B-    ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/formatter/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/regex/part2/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"regex","subTopicName":"regex","topic":{"topic_name":"regex","no_of_sub_topics":3,"folder_name":"regex","serial":10},"serial":1}},{"blogPK":{"topicName":"regex","subTopicName":"regex"},"content":"# Regex - part2## Beware of Backslashes- `\\w` means word character,- `Backslash` is also used as a part of an escape character,- Can be used to nullify the special meaning of `metacharacters`,  - Ex: `\\[[0-9]\\]`    - Will match `[` then `any digit` then `]`,    - Will match `[4]`, `[2]` etc,    - For expressing it, you need to use two `backslashes`,    - Regex for above will `\\\\[[0-9]\\\\]]`,- Ex: See `backslashTest()` in `Test.java`,  ```java  private static void backslashTest(){        //String regex = \"\\\\[[0-9]\\\\]\"; // valid      String regex = \"\\\\[[0-9]]\"; // both are valid. ] itself don't have special meaning. So backslashes is optional        Pattern pattern = Pattern.compile(regex);        String[] arr = {\"[0]\",\"[1\",\"[s]\",\"2]\",\"[5]\"};        for (String str : arr){          Matcher matcher = pattern.matcher(str);          if(matcher.find()){              System.out.println(str+\" -> passed\");          }          else {              System.out.println(str+\" -> failed\");          }      }    }  ```  Output  ```text  [0] -> passed  [1 -> failed  [s] -> failed  2] -> failed  [5] -> passed  [O] -> failed. This is capital 'O', not zero  ```## Quantifiers in Regular Expressions- We can specify `number of times` a character appear,- These are the quantifiers  <table>  <tr> <th>Quantifiers</th> <th>Meaning</th> </tr>  <tr> <th>*</th> <th>Zero or more times</th> </tr>  <tr> <th>+</th> <th>One or more times</th> </tr>  <tr> <th>?</th> <th>Once or not at all</th> </tr>  <tr> <th>{m}</th> <th>Exactly m times</th> </tr>  <tr> <th>{m, }</th> <th>At least m times</th> </tr>  <tr> <th>{m, n}</th> <th>At least m, but not more than n times</th> </tr>  </table>- `quantifiers` must follow a `character` or `character class` for which it specifies the quantity. Ex: `\\d+`,- Ex-1: See `quantifierTest1()` in `Test.java`,  - Will match word of the format `fName lName`. where,   - `fName` is at least `3` letter, and   - `lName` is `5 to 10` letters  ```java  private static void quantityTest(){      String regex = \"[a-zA-Z]{3,} [A-Za-z]{5,10}\";      Pattern pattern = Pattern.compile(regex);        String[] arr = { \"Ibne Sina\", \"Shujoy Kundu\",              \"Hasib Hasan Hasib Hasan\",              \"Mahir Abrar\", \"gd n8\"      };        for(String name : arr){          Matcher matcher = pattern.matcher(name);          if(matcher.matches()){              System.out.println(name+\" -> passed\");          }          else{              System.out.println(name+\" -> failed\");          }      }  }  ```  Output:  ```text  Ibne Sina -> failed  Shujoy Kundu -> passed  Hasib Hasan Hasib Hasan -> failed  Mahir Abrar -> passed  gd n8 -> failed  ```- Ex-2: See `quantifierTest2()` in `Test.java`,- Will match word  - consists of `small letter` and  - contain small `s` only one or not at all  ```java  private static void quantityTest2(){      String regex = \"[a-rt-z]*s?[a-rt-z]*\";      Pattern pattern = Pattern.compile(regex);        String[] arr = {\"amskn\",\"sssla\",\"substr\",\"ms\",\"s\"};        for(String str : arr){          Matcher matcher = pattern.matcher(str);            if(matcher.matches()){              System.out.println(str+\" -> passed\");          }          else{              System.out.println(str+\" -> failed\");          }        }  }  ```  Output:  ```  amskn -> passed  sssla -> failed  substr -> failed  ms -> passed  s -> passed  ```## Matching Boundaries- Finding location of match,- Ex: Replacing `apple` with `orange`:  ```  I have an apple and five pineapples // input   I have an orange and five pineapples // replaced  ```- Boundary matchers in java:  <img src=\"../files/boundary_matcher.jpg\" height=\"200px\">- Remember, A word character is defined by `[a-zA-Z_0-9]`,- `A word boundary` is a `zero-width match` that matches the following:  - Between a `word character` and a `non-word character`,  - `Start of the string` and a `word character`,  - A `word character` and the `end of the string`,- Similarly, a `non-word boundary` matches the following:  - The `empty string`,  - Between two word characters,  - Between two non-word characters,  - Between a non-word character and the start,  - Between a non-word character and end of the string,- For matching `apple` in earlier sentence regex should be `\\bapple\\b`,- Ex-1: See `boundaryMatcher1()` in `Test.java`,  ```java  private static void boundaryMatcher1(){      String input = \"I have an apple and five pineapples\";        String regex = \"\\\\bapple\\\\b\"; // Use \\\\b to get \\b inside the string literal      String replacedWith = \"orange\";        String output = input.replaceAll(regex,replacedWith);      System.out.println(output); // I have an orange and five pineapples  }  ```- Ex-2: See `boundaryMatcher1Manually()` in `Test.java`,  ```java  private static void boundaryMatcher1Manually(){      String input = \"apple, I have an apple, and five pineapples & two more apple\";        String regex = \"\\\\bapple\\\\b\";      Pattern pattern = Pattern.compile(regex);      Matcher matcher = pattern.matcher(input);      while (matcher.find()){          System.out.println(matcher.group()+\" from \"+matcher.start()+\" to \"+matcher.end());      }    }  ```  Output:  ```text  apple from 0 to 5  apple from 17 to 22  apple from 55 to 60  ```## Groups and Back Referencing- A `group` is created inside a RE by enclosing one or more characters inside `parentheses()`,- Ex: `(ab)`, `ab(z)`,- Each group in a RE has a `group number`,- `Group number` starts at `1`,- `groupCount()` that returns total number of groups found in `Matcher`,- There is a `special group`,  - Called `group 0`,  - It refers to the `entire RE`,  - This `group 0` is not reported by the `groupCount()` method,- For regex `((AB)(CD))(XY)`:  - `group-0`: `ABCDXY`  - `group-1`: `ABCD`  - `group-2`: `AB`  - `group-3`: `CD`  - `group-4`: `XY`- For finding group, find left parenthesis(`(`), then find the `corresponding `right parenthesis(`)`),- Ex: See `groupTest2()` in `Test.java`,   - Will find phone number,  - Find code & number from that phone number,  - Format the number & print  ```java  private static void groupTest2(){      String phones = \"+8801792101111, +8801234567890, +8804324567890,+2101234\";        String regex = \"(\\\\+\\\\d{3})(\\\\d+)\\\\b\"; // \\ is used before +, since + has special meaning      Pattern pattern = Pattern.compile(regex);        Matcher matcher = pattern.matcher(phones);        while (matcher.find()){          // String found = matcher.group(0); // or .group(); phone num            String code = matcher.group(1);          String num = matcher.group(2);            System.out.println(code+\" - \"+num);      }  }  ```  Output:  ```text  +880 - 1792101111  +880 - 1234567890  +880 - 4324567890  +210 - 1234  ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/regex/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/regex/part3/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"regex","subTopicName":"regex","topic":{"topic_name":"regex","no_of_sub_topics":3,"folder_name":"regex","serial":10},"serial":2}},{"blogPK":{"topicName":"regex","subTopicName":"regex"},"content":"# Regex - part3## Using Named Groups- group can be named instead of using with number,- Format:  ```java  (?<groupName>pattern)  ```- The group name must consist of  - Only `letters` and `digits`,  - `a to z`, `A to Z`, and `0 to 9`,  - Must start with `letter`,- Ex: See `groupTest2()` in `Test.java`,  - This is the previous example but using `name` instead of `number`,  - Will find phone number,  - Find code & number from that phone number,  - Format the number & print  ```java  private static void groupTest2(){      String phones = \"+8801792101111, +8801234567890, +8804324567890,+2101234\";        String regex = \"(\\\\+\\\\d{3})(\\\\d+)\\\\b\"; // <--------------      Pattern pattern = Pattern.compile(regex);        Matcher matcher = pattern.matcher(phones);        while (matcher.find()){          String code = matcher.group(1); // <--------------          String num = matcher.group(2); // <--------------            System.out.println(code+\" - \"+num);      }  }  ```  Output:  ```text  +880 - 1792101111  +880 - 1234567890  +880 - 4324567890  +210 - 1234  ```## Resetting the Matcher- `Matcher` class has a `reset()` method,- `reset()`:  - Next call to match a pattern will start from the `beginning` of the input text,  - Uses the same string,- `reset(input)`  - Next call to match a pattern will start from the `beginning` of the input text,  - Uses the provided `input` string,- Ex: See `resetTest()` in `Test.java`,  ```java  private static void resetTest(){      String[] arr = {\"+8801792101111\", \"+8801234567890\", \"+8804324567890\",\"+2101234\"};        String regex = \"(?<code>\\\\+\\\\d{3})(?<num>\\\\d+)\\\\b\";      Pattern pattern = Pattern.compile(regex);        Matcher matcher = pattern.matcher(\"\"); // dummy        for(String phone : arr){          matcher.reset(phone);          matcher.find();            String code = matcher.group(\"code\");          String num = matcher.group(\"num\");          System.out.println(code+\" - \"+num);      }    }  ```  Output:  ```text  +880 - 1792101111  +880 - 1234567890  +880 - 4324567890  +210 - 1234  ```## Find & Replace Using RE## Example- We are given this input:  ```text  A train carrying 125 men and women was traveling at the speed of   100 miles per hour. The train fare was 75 dollars per student.  ```- We want to replace number by text like this:  - `100` by `a hundred`,  - `> 100` by `more than a hundred`,  - `< 100` by `less than a hundred`,- Our output will be:  ```text  A train carrying more than a hundred men and women was traveling at the speed of   a hundred miles per hour. The train fare was less than a hundred dollars per student.  ```- For accomplishing that we have `2` methods in `Matcher` class,  - `Matcher appendReplacement(StringBuilder sb, String replacement)`:    - If this is the first match or `first call to the find()` then      - It appends the text `starting from the beginning of the input` until the `character before the matching text`,    - else      - It will append text from the previously saved position till character before the matching text,    - Then, it adds the replacementText to the `StringBuilder`,    - Then, it sets the `append position` ( in `Matcher` object) to the character position just `after previous matching text`,    - Continues,  - `StringBuilder appendTail(StringBuilder sb)`:    - Add rest of the part to `StringBuilder` after last saved position till end of the input,- Solution code: See `solution()` in `Test.java`,  ```java  private static void solution(){        String input = \"A train carrying 125 men and women was traveling at the speed of 100 miles per hour. \"+              \"The train fare was 75 dollars per student.\";        String regex = \"\\\\b\\\\d+\\\\b\";      Pattern pattern = Pattern.compile(regex);      Matcher matcher = pattern.matcher(input);        StringBuilder output = new StringBuilder();        while (matcher.find()){          String text = matcher.group();          int num = Integer.parseInt(text);            String replaceWith;            if(num == 100) replaceWith = \"a hundred\";          else if(num < 100) replaceWith = \"less than a hundred\";          else replaceWith = \"more than a hundred\";            matcher.appendReplacement(output,replaceWith);      }        matcher.appendTail(output); // rest of the part <-----------(a)      System.out.println(output); // A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred dollars per student.  }  ```- In above solution, body of while loop will be executed 3 times,- Content of `output` in each iteration is given:- `1st` iteration:  ```  A train carrying more than a hundred  ```- `2nd` iteration:  ```  A train carrying more than a hundred men and women was traveling at the speed of a hundred  ```- `3rd` iteration:  ```  A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred  ```- Outside while loop, at point `(a)`,  ```  A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred dollars per student.  ```>> Do you still remember the image while starting regex? \uD83D\uDC31<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/regex/part2/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/array/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"regex","subTopicName":"regex","topic":{"topic_name":"regex","no_of_sub_topics":3,"folder_name":"regex","serial":10},"serial":3}},{"blogPK":{"topicName":"array","subTopicName":"array"},"content":"# Array## Introduction- A fixed-length data structure that is used to hold more than one value of the same data type,- All elements of an array are stored contiguously in memory,  - In case of a reference type array, the array elements store the references of the objects,  - Those references in the elements are stored contiguously, not the objects they are referring to.   - The objects are stored on heap and their locations are, typically, not contiguous,- All arrays in Java are objects but `abstract` i.e. can't create object directly,- Since array are objects, so it can be assigned to other object. Rule is same,- Arrays are created dynamically at runtime,- The length of an array cannot be modified after it has been created,- Ex:    ```java    int[] arr = new int[5];    ```- Index is zero(`0`) based just like `C` or `C++`,- Make sure to assign values before using,- Ex:    ```java    private static void printArray(int[] arr){        for (int t : arr) {            System.out.print(t + \" \");        }        System.out.println(\"\");    }    private static <T> void printArray(T[] arr){        for (T t : arr) {            System.out.print(t + \" \");        }        System.out.println(\"\");    }    private static void arrayTest(){        int[] arr = new int[5];        for(int i=0;i<arr.length;i++) arr[i] = i+5;        Object obj = arr; // array are object. So assignment is possible        printArray(arr); // 5 6 7 8 9        int[] brr = (int[])obj;        printArray(brr); // 5 6 7 8 9        // default        String[] names = new String[4];        printArray(names); // null null null null        names[0] = \"Pantho\";        names[2] = \"Aslam\";        printArray(names); // Pantho null Aslam null        names[1] = \"Maruf\";        names[3] = \"Anik\";        printArray(names); // Pantho Maruf Aslam Anik        for (int i=0;i<names.length; i++){            names[i] = names[i].substring(0,1); // -------(a)        }        printArray(names); // P M A A    }    ```    - If you don't assign `Maruf` and `Anik`, then program will crash at `(a)`,## Initializing Array Elements- Array elements are initialized to a default value no matter it is global or local,- Array elements of primitive data type are initialized to the default value for their data types,  - Numeric array elements are initialized to zero(`0`),   - boolean elements to `false`,- Reference type elements to `null`,- Ex:    ```java    String[] names = new String[4];    printArray(names); // null null null null    ```- Explicit initializing:    ```java    int[] rolls = new int[]{1,2,3,4,5}; // or    int[] rolls2 = {1,2,3,4,5};    ```- You cannot specify the length of an array if you specify the array initialization list,- The length of the array is the same as the number of values specified in the initialization list, i.e. `5` in above example,## Limitations of Arrays- Cannot be expanded or shrunk after it is created,## Variable-Length Arrays- `ArrayList` and `Vector` are two classes in the `java.util` package that can be used whenever variable-length arrays are needed,- `ArrayList` and `Vector` classes work the same way except,  - Methods in the `Vector` class are `synchronized`(Thread safe),   - Whereas methods in `ArrayList` are not `synchronized`,  - `Vector` is slower, `ArrayList` is faster,- Use `ArrayList`,- Ex:    ```java    private static void arrayListTest(){        ArrayList<Integer> arr = new ArrayList<>();        arr.add(1);        arr.add(2000);        arr.add(3);        for(int i=0; i<arr.size(); i++) System.out.print(arr.get(i)+\" \");        System.out.println(\"\");        // 1 2000 3        System.out.println(arr.size()); // 3        arr.add(20);        arr.add(22);        System.out.println(arr.size()); // 5    }    ```## Passing array as parameter- Can be passed to method just like other variable,- Alert when modifying array inside called method. Remember, array are object, so modifying inside method will also modify original array,- Ex:    ```java    private static void resizeValues(int[] arr){        for(int i=0; i<arr.length; i++) {            if(arr[i] > 20) arr[i] = 20;        }    }    private static void passArray(){        int[] arr = {1,2,23,24,25,3};            printArray(arr); // 1 2 23 24 25 3        resizeValues(arr);        printArray(arr); // 1 2 20 20 20 3     }    ```- Make a copy then pass to method if you are going to modify inside method,- Remember, `main(String[])` method takes an array as parameter.## Multi-Dimensional Arrays- Just like `C` and `C++`,- Ex:    ```java    private static void multiDimenArray(){        int[][] table = new int[3][2];        int[][] tbl = {            {1,2},            {3,4},            {5,6}        };        for(int i=0;i<tbl.length; i++){            for(int j=0; j<tbl[i].length; j++){                System.out.print(tbl[i][j]+\" \");            }            System.out.println(\"\");        }        System.out.println(\"---\");        // better approach        for(int[] row : tbl){            for(int num : row){                System.out.print(num+\" \");            }            System.out.println(\"\");        }    }    ```    Output    ```text    1 2    3 4    5 6    ---    1 2    3 4     5 6    ```- All operations are like normal array. Just `don't be confused`,## Converting an ArrayList to an Array- Accessing array elements is faster than ArrayList,- You may convert when you know size won't be changed anymore.- Ex:    ```java    private static void arrayListToArray(){        System.out.println(\"------------------------------ arrayListToArray ---------------------\");        ArrayList<String> names = new ArrayList<>();        names.add(\"John\");        names.add(\"Jane\");        names.add(\"Mary\");        Object[] arr = names.toArray(); // <--------- way-1        printArray(arr); // John Jane Mary        String[] brr = new String[names.size()];        names.toArray(brr); // <------------ way-2        printArray(brr); // John Jane Mary    }    ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/regex/part3/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part1/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->","subTopic":{"topicName":"array","subTopicName":"array","topic":{"topic_name":"array","no_of_sub_topics":1,"folder_name":"array","serial":11},"serial":0}},{"blogPK":{"topicName":"inheritance","subTopicName":"inheritance"},"content":"# Inheritance - part1## Introduction- Important concept of OOP,- Lets you create `new-class` by reusing code from `existing-class`,- `new-class` is called `sub-class`, `child-lass`, `derived-class`,- `existing-class` is called `super-class` or `parent-class`,- For example: `PartTimeStudent` can inherit `Student`,- `is-a` relationship must exist among child and parent class. Ex:  - `PartTimeStudent` is a `Student`,  - `Manager` is an `Employee`,  - `Human` is a `Creature`- Done using `extends` keyword,    ```    public class Child extends Parent{    ```## Object Class is the Default Superclass- `extends Object` is implicitly added for `first` `Parent` class,- Any class can access code of `Object` class without extending it since it is implicitly extended to `Object` class,- Ex:    ```java     class A{ } // A extends Object class implicitly    class B extends Object{} // explicitly    public class Common {        /* ... */        private static void testForefatherObject(){            A a = new A();            B b = new B();            // hashCode() is defined in Object class. But we can use it here            System.out.println(a.hashCode()); // 733672688            System.out.println(b.hashCode()); // 297927961        }    }    ```## Inheritance and Hierarchical Relationship- `is-a` relationship must exist in inheritance,- All classes in an inheritance chain form a tree-like structure, which is known as an `inheritance-hierarchy` or a `class-hierarchy`,- All classes in Java have a `superclass` except the `Object` class,- Example inheritance hierarchy:  <img src=\"../files/inheritance_hierarchy.jpg\" height=\"200px\">- `Object` class is the `ancestor` implicitly,- From above hierarchy,  - `FullTimeManager` is an `Employee`,  - `Programmar` is an `Employee`,  - `Programmar` is an `Object` etc.## Things Inherited by a Subclass- A subclass `doesn't` inherit everything from its superclass. But,- A subclass may use, directly or indirectly, everything from its superclass,- A subclass inherits `non-private members`(`protected`, package-level and `public`) of its superclass,  - `public`: always inherited,  - `protected`: inherited no matter it is in same package or not,  - package-level: inherited only if `subclass` & `superclass` is in same package,- `Constructors` and `initializers` aren't members of a class, they are not inherited,- Members of a class are   - All members that are declared inside the body of the class &   - Members that it inherits from the superclass,  ## Upcasting and Down-casting- `subclass` can always be cast into `superclass`(`upcasting`),- `super-class` can be cast into `subclass` iff the variable of `superclass` refers object of the `subclass`(`downcasting`),- Ex:    ```java    private static void testUpDownCasting(){        Employee abulKalam = new Employee(1, \"Abul Kalam\", 50000);            Employee employee = new Manager(2,\"Employee\",20034,10000);            Manager atikurRahman = new Manager(1, \"Atikur Rahman\", 80000, 10000);            Employee emp;        emp = atikurRahman; // upCasting            Manager manager;        //manager = abulKalam; // compile error        //manager = employee; // compile error            //manager = (Manager)abulKalam; // runtime error <-------(a)            manager = (Manager) employee; // fine - Down-casting <----(b)        }    ```- While `down-casting`,   - Make sure the variable(`employee`) is holding the object of the class(`Manager`) to which(`Manager`) you are going to cast,    <img src=\"../files/type_check.jpg\" height=\"140px\">    - In `(a)`, `runtime-error` is thrown. Because,    - `compile-time` check is passed,    - Failed at runtime check,    - See above image## The `instanceof` Operator- Can be used for making sure that `downcast` will succeed,- An object is considered an instance of a class if   - That object is of that class type, or   - its direct or indirect descendant type, - You can use the `instanceof` operator to check if an object is an instance of a class or not,- It performs both `compile-time` and `runtime` check,- See <a href=\"https://github.com/abusaeed2433/JavaBasic/blob/66e6efc7f943f2414b38900a9303db3a12894e9b/src/q_Interfaces/info5.md#the-instanceof-operator\">instanceof at interface</a> for more,- Ex:  ```java  static private void instanceOfTest(){      Employee abulKalam = new Employee(1, \"Abul Kalam\", 50000);      Employee employee = new Manager(2,\"Employee\",20034,10000);        Manager manager;        if(employee instanceof Manager){          manager = (Manager) employee; // executed      }      else{          System.out.println(\"Can't down-cast\");      }        if(abulKalam instanceof Manager){          manager = (Manager)abulKalam;      }      else{          System.out.println(\"Can't down-cast\"); // executed      }  }  ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/array/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part2/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"inheritance","subTopicName":"inheritance","topic":{"topic_name":"inheritance","no_of_sub_topics":7,"folder_name":"inheritance","serial":12},"serial":1}},{"blogPK":{"topicName":"inheritance","subTopicName":"inheritance"},"content":"# Inheritance - part2## Binding- Classes have `methods` and `fields`,- Suppose:    ```java    public class Parent {            public void print(){            System.out.println(\"Inside parent\");        }            }    public class Child extends Parent{            public void print(){            System.out.println(\"Inside child\");        }        }    private static void basicBindingTest(){        Parent parent = new Child();        parent.print(); <------ (a)        parent = new Parent();        parent.print();    }    ```  - In `(a)`, which method will be called?  - In such situation, `binding` makes decision, which method or field will be accessed,  - There are two types of binding:    - `Early-binding`:      - Binding occurs at compile time,      - Also known as `static-binding`,    - `Late binding`:      - Binding occurs at runtime,       - Also known as `dynamic-binding`,## Early binding- Done by the compiler at `compile-time`,- Only used for the following types of `methods` and `fields` of a class in Java:  - All `static` and `non-static` fields,  - `Static` methods,  - `Non-static-final` methods,- In early binding, a `method` or a `field` is accessed based on the declared type,- Ex:    ```java    public class Parent {        private String name;        public static int id = 0;            public final void send(){            System.out.println(\"Parent sending...\");        }            public static void run(){            System.out.println(\"Parent running...\");        }            public void print(){            System.out.println(\"Parent printing...\");        }    }    ```    ```java    public class Child extends Parent{        private String type;        public static int id = 1;            public static void run(){            System.out.println(\"Child running...\");        }            public void print(){            System.out.println(\"Child printing...\");        }    }    ```    ```java    private static void earlyBindingTest(){        Parent parent = new Parent();         parent.send(); // Parent sending...        parent.run(); // Parent running...        System.out.println(parent.id); // 0            parent = new Child();         parent.send(); // Parent sending...        parent.run(); // Parent running...        System.out.println(parent.id); // 0                Child child = new Child();         child.send(); // Parent sending...        child.run(); // Child running...        System.out.println(child.id); // 1            ((Parent)child).send(); // Parent sending...        ((Parent)child).run(); // Parent running...        System.out.println(((Parent)child).id); // 0    }    ```  - As you can see, it doesn't matter which object the variable is referring,  - `methods` and `fields` are always accessed based on the variable type,## Late Binding- Used for `non-static`, `non-final` methods,- Ex:    ```java    private static void lateBindingTest(){        Parent parent = new Parent();        Child child = new Child();            parent.print(); //(1) Parent printing...            child.print(); //(2) Child printing...            ((Parent)child).print(); // (3) Child printing...                parent = child; // Upcasting            parent.print(); // (4) Child printing...    }    ```- At `(1)` & `(2)`, it is simply fine, i.e., calling method on object to which variable is referring,- At `(3)`,   - When you use a typecast such as `(Parent)child`, the object to which `child` refers to at runtime does not change,  - Using a typecast, all you say is that you want to use the object to which `child` variable refers as an object of `Parent` type. However, the object itself never changes,  - Since object is not changed and referring to `Child` class object, so `print()` of `Child` class is called,- At `(4)`, this is similar to `(3)`. Referring `Child` class object, so calling `Child` class method,- Late binding may cause little performance overhead,  - Because method call are resolved runtime,  - But this is actually made negligible by using `virtual method table`,- Provides a huge benefit to implement `polymorphism`,>> It's not hard, just try by yourself    <!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part3/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"inheritance","subTopicName":"inheritance","topic":{"topic_name":"inheritance","no_of_sub_topics":7,"folder_name":"inheritance","serial":12},"serial":2}},{"blogPK":{"topicName":"inheritance","subTopicName":"inheritance"},"content":"# Inheritance - part3## Method Overriding- Redefining a method in child class,- Ex:    ```java    public class Parent {            public void walk(){ // overridden method            System.out.println(\"Parent walking...\");        }        }    public class Child extends Parent{            @Override // optional annotation        public void walk(){ // overriding method            System.out.println(\"Child walking...\");        }        }    ```    Using like this:    ```java    private static void basicOverriding(){        Child child = new Child();        child.walk(); // Child walking...            Parent parent = new Parent();        parent.walk(); // Parent walking...            parent = child;        parent.walk(); // Child walking... because of late-binding    }    ```## Overriding rules### Rule-1:- Method must have to be an `instance` method,- Overriding doesn't apply to static methods.### Rule-2:- The `overriding-method` must have the same name as the `overridden-method`.### Rule-3:- The `overriding-method` must have the same number of parameters   - of the same type,  - in the same order as the `overridden-method`,  - `void print(String str)` & `void print(String msg)` are considered the same method,### Rule-4:- For primitive data type,  - `return-type` of both methods must be the same,- For reference data type,  - `return-type` of the `overriding-method` must be assignment compatible to the `return-type` of the `overridden-method`, i.e.,  - `Child-type` should be assignment compatible to `Parent-type`,- Ex:  ```java  public class Parent {      ...      int getOne(){ return 1; }      Parent getThis(){ return this; }      ...  }  ```  ```java  public class Child extends Parent{      ...      @Override      int getOne(){ return -1; }      @Override      Child getThis(){ return this; }      ...  }  ```  Using like this: See `overridingRule4()` in `Test.java`,  ```java  private static void overridingRule4(){      Parent parent = new Parent();      System.out.println(parent.getOne()); // 1        parent = new Child();      System.out.println(parent.getThis()); // Child  }  ```### Rule-5:- The access level of the `overriding-method` must be at least the `same or more relaxed` than that of the `overridden-method`,- `private` members can't be overridden since they are not inherited,- See this:- <img src=\"../files/relaxed_overriding_method.jpg\" height=\"160px\"/>### Rule-6:- The `overriding-method` can't add a new exception to the list of exceptions in the `overridden-method`,`(a)`- It may remove one or all exceptions, `(b)`- It may replace an exception with another exception, But exception must be child of `overridden-method` exception, `(c)`- Ex: See `CheckedException1.java`, `CheckedException2.java`, `CheckedException11.java`, `Father.java`, `Son.java`,   ```java  public class CheckedException1 extends Exception{ }  ```  ```java  public class CheckedException2 extends Exception{ }  ```  ```java  public class CheckedException11 extends CheckedException1{ }  ```  ```java  public class Father {      public void calc(int x) throws CheckedException1, IOException {          System.out.println(\"Father\");          if(x == -1) throw new CheckedException1();          if(x == 0) throw new IOException();      }  }  ```  ```java  public class Son extends Father{    //    @Override  //    public void calc(int x) throws CheckedException11, IOException {//fine (c)  //        System.out.println(\"Son\");  //    }      //    @Override  //    public void calc(int x) throws CheckedException2{ // error <------(a)  //        System.out.println(\"Son\");  //    }      //    @Override  //    public void calc(int x) throws CheckedException1{ // valid (b)  //        System.out.println(\"Son\");  //    }        @Override      public void calc(int x){ // valid (b)          System.out.println(\"Son\");      }  }  ```## Overriding summary- Remember  - Name of the method: `same`,  - Number of parameters: `same`,  - Type of parameters: `same`,  - Order of parameters: `same`,  - Return type: `same` or `child` of `overridden-method` `return-type`,  - Access level: `same` or `less`,  - List of checked exceptions: `same` or `less`,- Ex: `access-level` of `overridden-method` should be `same` or `less` restrictive than `access-level` of `overriding-method`,- You will get `compile-time` error if you make any error. So don't worry,- Golden rule about method overriding:   - `Whatever code is written using the superclass type must also work with the subclass type`,## Accessing overridden method- A subclass can use the keyword `super` to call the `overridden-method` of the superclass,- Ex: See `Son.java`,  ```java  @Override  public void calc(int x) throws CheckedException1, IOException {      super.calc(x); // calling calc(int) of Father class  }  ```>> Basic overriding knowledge is enough in almost most of the cases<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part2/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part4/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"inheritance","subTopicName":"inheritance","topic":{"topic_name":"inheritance","no_of_sub_topics":7,"folder_name":"inheritance","serial":12},"serial":3}},{"blogPK":{"topicName":"inheritance","subTopicName":"inheritance"},"content":"# Inheritance - part4## Method overloading- Having more than one method with the `same name` in the `same class`,- Methods could be declared methods, inherited methods, or a combination of both,- At least one of this must differ:   - `Number of parameters,`   - `Types of parameters`,- Things that doesn't matter:  - The return type,   - Access level,  - `throws` clause,- It is another kind of polymorphism where the same method name has different meanings,- It is bound at `compile time` as opposed to `method overriding` that is bound at runtime,- For an overloaded method call:  - Compiler chooses the **most specific** method,  - If it **doesn't** find an exact match, it will try to **look for a more generic version** by converting actual parameter into a more generic type,- Ex-1:    ```java    private static int add(int x, int y){        int res = (x+y);        System.out.println(\"int add\");        return res;    }        private static double add(double x, double y){        double res = x+y;        System.out.println(\"double add\");        return res;    }    ```    Calling like:    ```java    System.out.println( add(5,10) ); // 15    System.out.println( add(5.0,10) ); // 15.8    ```- Ex-2:    ```java    public class MyMath {        public double sub(int a, double b) { return a - b; }          public double sub(double a, int b) { return a - b; }    }    ```    Calling like:    ```java    MyMath myMath = new MyMath();    myMath.sub(5.0,2); // fine    myMath.sub(5,2.0); // fine    //myMath.sub(5,5); // ambiguous - compile-time error    ```- Last one is ambiguous, because compiler can use both `sub()` methods,- Most of the error will be compile-time. So don't worry,> Overloading is simple. Just don't be confused,## Inheritance and Constructors- Constructors are `not inherited by subclasses` since they are not member of a class,- To initialize the instance variables of `Parent` classes, the constructors of `Parent` class must be called,- `super` keyword is used in child class for calling parent class constructor,- Constructor of `Parent` class is called first then `Child` class,- Ex:  ```java  public class Parent {      public Parent() {          System.out.println(\"parent constructor\");      }  }  ```  ```java  public class Child extends Parent{      public Child() {          // super(); // is automatically inserted          System.out.println(\"Child constructor\");      }  }  ```  Calling like this:  ```java  private static void testConstructorSequence(){      Child child = new Child();      /*       Output       parent constructor       Child constructor      */  }  ```- Here `super()`:  - Calls `Parent` class constructor,  - Calls no argument constructor of `Parent` class,  - Is automatically added by compiler,  - Must be the first statement of a constructor,- If constructor of `Parent` class takes some parameter then simply pass those inside `super(here)`,- Ex:  ```java  public class Vehicle {      String brand;      public Vehicle(String brand) {          this.brand = brand;      }      ...  }  ```  ```java  public class Car extends Vehicle{      int noOfDoors;      public Car(String brand, int noOfDoors) {          super(brand); // <------------ calling parent class constructor and passing brand value          this.noOfDoors = noOfDoors;      }      ...  }  ```  Using like this:  ```java  private static void testConstructorParameter(){      Car myCar = new Car(\"Toyota\", 4);        System.out.println(myCar.brand); // Toyota      System.out.println(myCar.noOfDoors); // 4  }  ```## Method hiding- `Child` class inherits all non-private static methods of `Parent` class,- Redefining a static method in `Child` class hide the static method in `Parent` class,- The redefined static method in a subclass is said to hide the static method of its superclass,- Recall that redefining a non-static method in a class is called `method overriding`, not `method-hidiing`,- Redefining rules are same as method overriding rules,- Remember, early binding is used for static methods,- Ex:  ```java  public class SuperClass {      public static void print() {          System.out.println(\"Super.print()\");      }  }  ```  ```java  public class SubClass extends SuperClass{      public static void print() {          System.out.println(\"Sub.print()\");      }  }  ```  ```java  private static void testHidingBasic(){        SuperClass spr = new SuperClass();      SubClass sub = new SubClass();        SuperClass.print(); // Super.print()      spr.print(); // Super.print()          SubClass.print(); // Sub.print()      sub.print(); // Sub.print()      ((SuperClass) sub).print(); // Super.print() <----(a)        spr = sub;      spr.print(); // Super.print() <---------------(b)      ((SubClass) spr).print(); // Sub.print()    }  ```- Explanation of above example:  - All are normally executed till `(a)`,  - At `(a)`,     - The `compile-time` type of the `sub` variable is `SubClass`,    - After typecasting, the `compile-time` type of `(SuperClass)sub` becomes `SuperClass`,    - So `print()` of `SuperClass` is being called,  - At `(b)`,    - After `spr = sub;`, `compile-time` type of `spr` is still `SuperClass`,    - So, `print()` of `SuperClass` is being called,  - Last one is similar to `(b)`,  - A static method of a class cannot hide an instance method of its superclass- It just hides the `Parent` class implementation of a static method, Nothing more,- **Remember, always call static method using ClassName,**## Field Hiding- A field (`static` or `non-static`) in a `subclass` hides the inherited field with the same name in its `superclass`,- Occurs solely based on the field `name`,- The `type of the field` and its `access level` doesn't matter,- Remember, `early-binding` is used for field access,- Use `super` keyword to access the hidden fields of the `superclass`,- Ex:  ```java  public class Mother {      private static final String PREFIX = \"MRS\";      protected String name;        public Mother(String name) {          this.name = name;      }        public void printFormattedName(){          System.out.println(PREFIX+\" \"+name);      }      ...  }  ```  ```java  public class Daughter extends Mother{      private static final String PREFIX = \"MISS\";      private String name;        public Daughter(String name) {          super(\"Don't know\");          this.name = name;      }        public void printParentField(){          System.out.println(super.name);      }        public void printFormattedName(){          System.out.println(PREFIX+\" \"+name); // will use daughter name. hide name of Daughter      }      ...  }  ```  Using like this:  ```java  private static void testFieldHiding(){         Mother mother = new Mother(\"Rumi\");      Daughter daughter = new Daughter(\"Tisha\");        mother.printFormattedName(); // MRS Rumi      daughter.printFormattedName(); // MISS Tisha      daughter.printParentField(); // Don't know    }  ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part3/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part5/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"inheritance","subTopicName":"inheritance","topic":{"topic_name":"inheritance","no_of_sub_topics":7,"folder_name":"inheritance","serial":12},"serial":4}},{"blogPK":{"topicName":"inheritance","subTopicName":"inheritance"},"content":"# Inheritance - part5## Disabling Inheritance- Prevent class from being used as parent class,- Done by making a class final by adding `final` in class declaration,- A method can be `final` also,- A final method cannot be `overridden` or `hidden` by a `subclass`,- Ex: `String` class is `final`,- Why to disable inheritance?   - Main reasons are `security`, `correctness`, & `performance`,  - If your class is important for security reasons, you do not want someone to inherit from your class and mess with the security that your class is supposed to implement,  - A `final` method may result in better performance at runtime because a code optimizer is free to inline the final method calls,- Ex of `final-class`:   ```java  public final class Parent{ }  ```  ```java  public class Child extends Parent{} // compile-time error  ```- Ex of `final-method`:  ```java  public class DummyParent {        protected final void start(){          System.out.println(\"Parent starting...\");      }  }  ```  ```java  public class DummyChild extends DummyParent{        protected final void start(){ //compile time error          System.out.println(\"Parent starting...\");      }  }  ```## Abstract Classes and Methods- A class whose instance can't be created,- Opposite of `abstract-class` is `concrete-class`,- Abstract class   - Indicates that the class has some incomplete method,   - Considered incomplete for object creation purposes,- Abstract method  - Has a declaration, but no `body` at all,  - Braces are replaced with a semicolon(`;`),  - Indicated using `abstract` keyword,- An `abstract-class` may have all concrete methods or no concrete methods at all,- For sake of understanding:  - Declaring a class as abstract is like placing an `under construction` sign in front of a building,  - If an `under construction` sign is placed in front of a building, it is not supposed to be used (not supposed to be created in case of a class),  - It does not matter whether the building is complete(`all concrete methods`) or not(`some abstract methods`),- Mainly used for using as `Parent` class,- It is completely similar like normal class, only difference is, you can't create object of `abstract-class`,- Ex:  ```java  public abstract class Shape {      protected final double PI = 3.14159;      private String name;            public Shape(String name) {          this.name = name;      }      ...      protected abstract void draw();      protected abstract double getArea();  }  ```  ```java  public class Circle extends Shape{      private double r;        public Circle(String name, double r) {          super(name);          this.r = r;      }        @Override      protected void draw() {          System.out.println(\"Circle\");      }        @Override      protected double getArea() {          return PI*r*r;      }  }  ```  ```java  public class Rectangle extends Shape{      private double width;      private double height;        public Rectangle(String name, double width, double height) {          super(name);          this.width = width;          this.height = height;      }      ...            @Override      protected void draw() {          System.out.println(\"Rectangle\");      }            @Override      protected double getArea() {          return width*height;      }  }  ```  Using like this:  ```java  private static void testAbstract(){      Shape rectangle = new Rectangle(\"Rectangle\",5,10); // <----(m)      rectangle.draw(); // Rectangle        Shape circle = new Circle(\"Circle\",5); // <-------------(a)      System.out.println(circle.getArea()); // 78.53975 <-----(b)  }  ```- In above example, `(a)` & `(b)` involve these `OOP` concept:  - `abstract-class`: `Shape` class is abstract,  - `abstract-method`: `draw()` and `getArea()` are `abstract`,  - `upcasting`: Object of `Circle` is cast to `Shape` type at `(a)`,  - `method-overriding`: `draw()` & `getArea()` are overridden in `Circle` and `Rectangle` class,  - `late-binding`: At `(b)`, `getArea()` is determined at runtime,  - `runtime-polymorphism`: `(m)`, `(a)` & method calls,- The greatest advantage of declaring an `abstract method` in a class is to force its `subclasses` to `override` and provide implementation for those methods,- Ex-2:  ```java  private static void printName(Shape[] shapes){      for(int i=0; i<shapes.length; i++){          Shape sp = shapes[i];          System.out.print(sp.getName());            if(i != shapes.length - 1) System.out.print(\", \");      }      System.out.println(\"\");  }    private static void testAbstract2() {        Shape[] shapes = new Shape[6];        for(int i=0; i<shapes.length; i++){          int rand = new Random().nextInt(10);          shapes[i] = (rand % 2 == 0) ? new Rectangle(\"Rectangle\",2,4) : new Circle(\"Circle\",5);      }      printName(shapes); // Circle, Circle, Circle, Rectangle, Rectangle, Circle  }  ```  - As you can see it doesn't matter which object variable of `Shape` class holding,  - We can simply call the method, and it will be determined at runtime,- Just see a bit- An abstract class cannot be declared `final`. Since `final class` cannot be `subclassed`, which conflicts with the requirement of an `abstract-class`,- An `abstract-class` shouldn't declare all constructors `private`. Otherwise, the `abstract-class` cannot be subclassed,- An `abstract-method` can't be declared `static`,- An `abstract-method` can't be declared `private`. Recall that a `private-method` isn't inherited and hence it can't be overridden,- An `abstract-method` in a class can `override` an `abstract-method` in its superclass without providing an implementation,- A `concrete instance method` may be overridden by an `abstract instance method`,- An abstract method cannot be declared `native`, `strictfp`, `synchronized`. Because,   - These keywords refer to implementation details of a method, But  - an abstract method does not have an implementation,<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part4/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part6/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"inheritance","subTopicName":"inheritance","topic":{"topic_name":"inheritance","no_of_sub_topics":7,"folder_name":"inheritance","serial":12},"serial":5}},{"blogPK":{"topicName":"inheritance","subTopicName":"inheritance"},"content":"# Inheritance - part6## Method Overriding and Generic Method Signatures- When Java codes with generics types is compiled, the generic types are transformed into raw types,- The process that is used to transform the generic type parameters information is known as `type erasure`,- Ex:    ```java    public class GenericSuper<T> {        public void m1(T a) { }            public <P extends Employee> void m2(P a) { }    }    ```    When the `GenericSuper` class is compiled, the `erasure` transforms the code during compilation and the resulting code looks as shown    ```java    public class GenericSuper {        public void m1(Object a) { }            public void m2(Employee a) { }    }    ```- Overriding generic class like:    ```java    public class GenericSub extends GenericSuper<Object>{        public void m1(Object a) { }            public void m2(Employee a) { }    }    ```- In overriding generic class,  - You may think that they(`m1()`, `m2()`) don't have the same signature. But,  - If a method uses generic parameters, you need to compare its `erasure`, not the generic version of its declaration,  - So, comparing with `erasure`, overriding is completely valid,## Typo Danger in Method Overriding- Ex:  ```java  public void m1(double num) { } // in Parent class  ```  ```java  public void m1(int num) { } // in Child class  ```  Here 2nd `m1()` won't override 1st `m1()` since parameter type is different,- Always use `@Override` annotation in `overriding-method`,- After using `@Override` annotation, compiler will check if overriding is actually done. If not it will show compile-time error,## is-a relationship- This is nothing but `inheritance`,- Ex: `FullTimeStudent` is a `Student`,## Aggregation / has-a relationship- An object of a class contains an object of another class,- It is known as `aggregation`,- Ex:  ```java  public class Address {      private String street;      private String city;      private String state;      private int postalCode;        public Address(String street, String city, String state, int postalCode) {          this.street = street;          this.city = city;          this.state = state;          this.postalCode = postalCode;      }      ...  }  ```  ```java  public class Person {      private String name;      private String phone;      private String email;      private Address address; // <--------------------(a)        public Person(String name, String phone, String email, Address address) {          this.name = name;          this.phone = phone;          this.email = email;          this.address = address;      }      ...      public void setAddress(Address address) {          this.address = address;      }  }    ```  At line `(a)`, `Person` class has an `Address` variable for storing `Address` info of the student,- This is `has-a` relationship. Since above relation can be expressed as `Person has an Address`,- In above example, instead of `Address` field in `Person` class, we can use all fields of `Address` class. But,  - It will make code hard to understand, &  - It Will be complex if we want `Person` to have multiple `Address`,## Composition / part-of relationship- Known as `composition`,- Strong type of `aggregation`,- The `whole`(main) controls the creation/destruction of the `part`(nested),- Sometimes existence of an object only make sense inside another object,- For example: `MobileDisplay` is a part of a `Mobile`, & - If `Mobile` is destroyed then its `MobileDisplay` is also destroyed,- Ex-1(`Nested class`):  ```java  public class Mobile {      private String brand;      private MobileDisplay display;        public Mobile(String brand) {          this.brand = brand;          this.display = new MobileDisplay(16);      }      ...      public void showData(){ display.showSomething(); }        private class MobileDisplay { // <-------------- nested class          private int density;          public MobileDisplay(int density) { this.density = density; }            private void showSomething(){              for(int i=0; i<density; i++){                  System.out.print(\"@\");              }              System.out.println(\"\");          }          ...      }    }  ```  Can be used like this:  ```java  private static void testComposition1(){      Mobile mobile = new Mobile(\"Nokia\");      mobile.showData(); // @@@@@@@@@@@@@@@@  }  ```- In above example, you can't use `MobileDisplay` outside `Mobile` class. But it may be needed to use `MobileDisplay` others,- Ex-2:  ```java  public class Engine {      private String type;      ...  }  ```  ```java  public class Car {      private String brand;      private Engine engine;        public Car(String brand, String engineType) {          this.brand = brand;          this.engine = new Engine(engineType); // creating here      }        public String getBrand() {          return brand;      }        public Engine getEngine() {          return engine;      }    }  ```  Using like this:  ```java  private static void testComposition2(){        Car myCar = new Car(\"Toyota\", \"Gasoline\");      System.out.println(myCar.getBrand()); // Toyota      System.out.println(myCar.getEngine().getType()); // Gasoline  }  ```- Use whatever you need based on your need,- In both example, nested object(`part`) can't exist without the existence of main(`whole`) object, since `Engine` and `MobileDisplay` are created inside the `Car` and `Mobile` class,## aggregation vs composition<table><tr>  <th>Aspect</th>  <th>Aggregation</th>  <th>Composition</th></tr><tr>  <td>Relationship</td>  <td>Indicates Has-a relationship</td>  <td>Indicates part-of relationship</td></tr><tr><td>Lifespan</td><td>Both object has independent life-cycle</td><td>Lifecycle of part is dependent on whole</td></tr><tr><td>Example</td><td>Peron has an Address</td><td>Engine is part of Car</td></tr></table>## inheritance or composition ?- Both let you share the code,- Whenever you are in doubt in choosing between `composition` and `inheritance`, give preference to `composition`,<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part5/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part7/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"inheritance","subTopicName":"inheritance","topic":{"topic_name":"inheritance","no_of_sub_topics":7,"folder_name":"inheritance","serial":12},"serial":6}},{"blogPK":{"topicName":"inheritance","subTopicName":"inheritance"},"content":"# Inheritance - part7## No Multiple Inheritance of Classes- Is defined as having a class inherited from more than one superclass,- Java **doesn't support** multiple inheritance of class,- There is no `Diamod-problem`,  - Diamond problem    - <img src=\"../files/diamond_problem.jpeg\" height=\"180px\" >     - Occurs when same method(`a1()`) is available in more than one parent class(`B`, `C`),    - So, after inheriting, compiler will be confused which one to call,- Java don't have such problem,## inheritance summary- ### inheritance:  - Promotes code `reuse`,  - lets you write code in terms of a class that works for the class and all its `subclasses`,  - The `subclass` inherits `members` of its `superclass` based on some rules,  - `Constructors` aren't inherited by `subclasses`,  - If a class declaration does not contain the keyword `extends`, the class implicitly inherits the `Object` class,  - A subclass may access the `constructors`, `methods`, and `fields` of its `superclass` using the keyword `super`,  - The call to access the `constructor` of the `superclass` must be the `first` statement in the `constructor` of the `subclass`,- ### Early binding:  - Compiler determines `fields` and `methods` to be accessed, based on the `compile-time` type,  - Used for accessing all types of `fields` and `static methods`,- ### Late binding:  - `Runtime-type` of the reference variable determines the `method` that is executed,  - Used for accessing `instance methods`,- ### upcasting:  - variable of a `superclass` can always hold a reference of its `subclasses`,- ### down-casting:  - A variable of a `subclass` is type cast and assigned to a variable of the `superclass`,  - For a `downcasting` to succeed at runtime, the variable of the `superclass` must contain a reference of     - The `subclass`, or     - The `subclasses` of the `subclass`,- ### `instanceof`:  - Used to test whether a reference variable is an `object` of a specific class,- ### Abstract class:  - Can't be `instantiated`,  - Can be declared `abstract` even if it contains no `abstract-methods`,  - `Abstract methods` are supposed to be `overridden` and provided an implementation by `subclasses`,- ### method hiding:  - Redefining the `static methods` of a `superclass` inside a `subclass`,  - `Hidden methods` may be accessed from the `subclass` using the `superclass class name` as the qualifier for the method.- ### field hiding:  - A `field` with the `same name` hides the `field` in the `superclass`,  - `Hidden field` may be accessed by using the keyword `super`,- ### final class & method:  - `Classes` and `methods` may be declared `final`,  - A `final` `class` & `method` can't be `inherited`,    >> There are two ways to write error-free programs; only the third one works. (Alan J. Perlis)<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part6/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part1/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"inheritance","subTopicName":"inheritance","topic":{"topic_name":"inheritance","no_of_sub_topics":7,"folder_name":"inheritance","serial":12},"serial":7}},{"blogPK":{"topicName":"interfaces","subTopicName":"interfaces"},"content":"# Interface - part1> BROAD AND CONFUSING TOPIC. PRACTICE MORE## Introduction- Very important concept,- Let us understand the need by considering a case,- Suppose we have a `Person` class which has `walk()` method in it,- We have a method named `letThemWalk(Person[])` defined as:    ```java    public static void letThemWalk(Person[] list){        for(Person student : list) {            student.walk();        }    }    ```    Calling the method like:    ```java    Person[] persons = new Person[3];    persons[0] = new Person(\"Jack\");    persons[1] = new Person(\"Jeff\");    persons[2] = new Person(\"John\");    letThemWalk(persons); // <---------------    ```- `letThemWalk(Person[])` will be executed `3` times. There is no problem till now,- Let us add a class named `Duck` in our project,- `Duck` can also walk. Except this, there is no similarity between `Person` & `Duck`,- So, there can have many such class(`Dog`,`Cat`...) that can have `walk()` method,- But we can't use them based on this property(`Walkable`) only, since all are different classes.## Some Solution of above problem- Solution-1:   - Using `Object` class array instead of `Person` class array,  - Ex:    ```java    private static Method getWalkMethod(Object obj) {        Class c = obj.getClass();        Method walkMethod = null;        try {            walkMethod = c.getMethod(\"walk\");            return walkMethod;        }        catch (NoSuchMethodException e) {            // walk() method does not exist        }        return null;    }    ```    `getWalkMethod(Object)` return the reference of `walk()` method if available in parameter class    ```java    private static void letThemWalkUpdated(Object[] list){        for(Object  obj : list) {            Method walkMethod = getWalkMethod(obj); // getting method reference            if (walkMethod != null) {                try {                    walkMethod.invoke(obj); // calling walk method on the obj                }                catch (Exception e) {                    e.printStackTrace();                }            }        }    }    ```    ```java    private static void solution1(){        Object[] objects = new Object[4];        objects[0] = new Person(\"Jack\");        objects[1] = new Person(\"Jeff\");        objects[2] = new Person(\"John\");        objects[3] = new Duck(\"Duck1\");        letThemWalkUpdated(objects);    }    ```  - This code will work fine. But,  - Problem here is: it will stop working if method name is changed,  - It is also confusing and hard to debug.- Solution-2:  - Use different function for `Person` and `Duck` class,    ```java    private static void letDuckWalk(Duck[] list){        for(Duck duck : list) {            if(duck == null) continue;            duck.walk();        }    }    ```    ```java    private static void letPersonWalk(Person[] list){        for(Person student : list) {            if(student == null) continue;            student.walk();        }    }    ```    ```java    private static void solution2(){        Person[] persons = new Person[3];        persons[0] = new Person(\"Jack\");        persons[1] = new Person(\"Jeff\");        persons[2] = new Person(\"John\");        letPersonWalk(persons); // <-------        Duck[] ducks = new Duck[3];        ducks[0] = new Duck(\"Ab\");        ducks[1] = new Duck(\"Bc\");        ducks[2] = new Duck(\"Ka\");        letDuckWalk(ducks); // <----------    }    ```  - It's not good solution at all since we need to write different function for every class.- Solution-3:  - We can create a parent class named say `Animal` then inherit this into `Person` and `Duck` class,  - Not good because it requires a parent class,  - Try yourself if you want to.## Ideal solution for above problem- We can create an interface named `Walkable` then implement this to `Person2` and `Duck2` class,- `Person` and `Person2` are same,- `Duck` and `Duck2` are same,- `Person2` & `Duck2` are created for separating this solution from earlier only,- Ex:  ```java  private static void idealSolution(){      Walkable[] arr = new Walkable[4]; // <----- See variable type      arr[0] = new Person2(\"Abu\");      arr[1] = new Person2(\"Saeed\");      arr[2] = new Person2(\"John\");        arr[3] = new Duck2(\"duck1\"); // <------- Duck2      letAllWalkTogether(arr);  }  ```  ```java  private static void letAllWalkTogether(Walkable[] arr){      for(Walkable obj : arr){          obj.walk();      }  }  ```- Perfect and simplest solution. Isn't it?## About interface- Declared using the keyword `interface`, - Can have abstract method declarations,- A class can implement one or more interfaces using the keyword `implements` in its declaration,- By implementing an interface, a class guarantees that it will provide an implementation for all methods declared in the interface or the class will declare itself abstract,- Can't create object of an interface type,- Ex:  ```java  public interface Walkable {      void walk();  }  ```- See `Person2.java` & `Duck2.java`:  ```java  public class Person2 implements Walkable{      private String name;      public Person2(String name) {          this.name = name;      }        @Override      public void walk() {          System.out.println(name + \" (a student) is walking.\");      }    }  ```- Now this statement becomes valid. i.e. variable of interface can refer to the object of class that implements this interface,  ```java  Walkable walkable = new Person2(\"Doe\");  walkable.walk(); // --------(a)  ```  `(a)` will automatically call `walk()` method of `Person2` class. No need to define explicitly,- `interface` lets you put unrelated classes under one umbrella. For example: object of `Person2` and `Duck2` can be referred using the variable of `Walkable` interface.<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/inheritance/part7/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part2/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"interfaces","subTopicName":"interfaces","topic":{"topic_name":"interfaces","no_of_sub_topics":7,"folder_name":"interfaces","serial":13},"serial":1}},{"blogPK":{"topicName":"interfaces","subTopicName":"interfaces"},"content":"# Interface - part2> Try to understand basic structure with `field` and `Abstract methods`. You can ignore from 3-lines separator## Declaring an Interface- Can be declared as   - A top-level interface(general),  - A nested interface,  - An annotation type,- Generally interface means top-level interface,- Structure:    ```java    <modifiers> interface <interface-name> {        Constant-Declaration        Method-Declaration        Nested-Type-Declaration    }    ```- modifiers are same as class modifier,- interface-name is a valid java identifier,- An interface declaration is always abstract whether you declare it abstract explicitly or not,- Ex: See `Clickable.java`    ```java    public interface Clickable {       // body of interface. Discussed later        }    ```## Declaring Interface Members- An interface can have three types of members,  - Constant fields,  - Abstract, static, and default methods,  - Static types (nested interfaces and classes)- All members of an interface are implicitly public,- An interface cannot have `mutable`(changeable) instance and class variables. Because we can't create object of an interface.## Constant Fields Declarations- All fields in an interface are implicitly `public`, `static` and `final`,- No need to write `public`, `static` and `final` explicitly,- Constant field can be accessed using dot(`.`),- Since fields are `final`, so you must have to initialize it while declaring,- It is a convention to use uppercase letters in the field name,- Ex:    ```java    public interface Clickable {        int SINGLE_CLICK = 1;        int DOUBLE_CLICK = 2;        int DOUBLE_CLICK_INTERVAL = 500; // ms    }    ```- Can be used like this:  ```java  private static void testConstantField(){      System.out.println(Clickable.SINGLE_CLICK); // 1        System.out.println(Clickable.DOUBLE_CLICK_INTERVAL); // 500        //Clickable.DOUBLE_CLICK = 10; // error since implicitly final  }  ```## Methods Declarations- Can declare three types of methods in an interface,  - Abstract methods in interface,    - Are implicitly `abstract` and `public`,    - Doesn't have body,    - May include parameters, a return type, and a `throws` clause,    - Can't be `final` since final method can't be overridden,    - Ex:       ```java       public interface Clickable {           /*...*/           // public abstract void onViewSingleClick(); // same as below one           void onViewSingleClick();           void onViewDoubleClick() throws RuntimeException;       }       ```    <hr>    <hr>    <hr>  - Static methods,    - They are implicitly public,    - Must be called on interface name,    - Can't be called on variable,    - Ex:      ```java      public interface Clickable {         /*...*/         static void printConstant(){             System.out.println(\"SINGLE_CLICK: \"+SINGLE_CLICK);             System.out.println(\"DOUBLE_CLICK: \"+DOUBLE_CLICK);             System.out.println(\"DOUBLE_CLICK_INTERVAL: \"+DOUBLE_CLICK_INTERVAL);         };      }      ```      Must be called like this:      ```java      private static void staticMethodTest(){         Clickable.printConstant();                 Clickable c = new MyItem();         //c.printConstant(); // error      }      ```  - Default methods,    - Provides a default implementation for the method,    - Declared with `default` keyword,    - Optional to override `default` method in a `class` that implements the interface,    - One reason why to use `default` method,      - Suppose you have developed an interface and used it in many places,      - You want to add a new method in the interface,      - If you add a new method, you will have to override this method in every class that implements the interface,      - Solution is to add a `default` method by providing a default implementation,      - Since `default` method is optional to override. So,      - You can add any number of `default` method without modifying existing code,    - Have access to the keyword `this` in the same way as class,    - Ex:      ```java        public interface Clickable {            int SINGLE_CLICK = 1;            int DOUBLE_CLICK = 2;            int DOUBLE_CLICK_INTERVAL = 500; // ms            //public abstract void onClick();            void onViewSingleClick();            void onViewDoubleClick() throws RuntimeException;            static void printConstant(){                System.out.println(\"SINGLE_CLICK: \"+SINGLE_CLICK);                System.out.println(\"DOUBLE_CLICK: \"+DOUBLE_CLICK);                System.out.println(\"DOUBLE_CLICK_INTERVAL: \"+DOUBLE_CLICK_INTERVAL);            }            default void requestSingleClick(){                this.onViewSingleClick(); //            }        }      ```            ```java      public class MyItem implements Clickable{         @Override         public void onViewSingleClick() {            System.out.println(\"Single click\");         }         @Override         public void onViewDoubleClick() throws RuntimeException {            System.out.println(\"Double click\");         }      }      ```      Accessing like this:      ```java      private static void defaultMethodTest(){         Clickable myItem = new MyItem();         myItem.requestSingleClick(); // Single click      }      ```    - See we haven't overridden `requestSingleClick()` method in `MyItem.java`,    - But we can override if we want to. It's optional,## Nested Type Declarations- Declared inside an interface,- Can declare a `class`, `interface`, `enum`, and `annotation` as nested types,- As we know, an `interface` and a `class` define new reference types, so do a `nested-interface` and a `nested-class`,- Sometimes it makes more sense to define nested type. For example: declaring `Card` interface inside `ATM` interface. Existence of `Card` makes more sense inside `ATM` and it isn't needed outside also,- A nested interface is always accessed through its enclosing interface(outer interface),- All nested types are implicitly `public` and `static`,- You can also declare class inside interface. But it's not common. Though it can be used for organizing related entities,- Nested type increases code readability and helps to organize code,- Nested interface example: See `ATM.java` and `MyAccount.java`(implementing multiple interface is discussed later),  ```java  public interface ATM {            boolean login(int account);      boolean deposit(double amount);      boolean withdraw(double amount);       double getBalance();            interface Card {          String getNumber();          String getSecurityCode();          LocalDate getExpirationDate();          String getCardHolderName();      }     }  ```- Nested class example: See `Job.java` and `Test.java`,  ```java  public interface Job {        class EmptyJob implements Job {          private EmptyJob() {              // Do not allow outside to create its object          }          public void runJob() {              System.out.println(\"Nothing\");          }      }        Job EMPTY_JOB = new EmptyJob(); // constant      void runJob();  }  ```  Calling like this:  ```java  private static void nestedClassTest(){      Job.EMPTY_JOB.runJob();  }  ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part3/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"interfaces","subTopicName":"interfaces","topic":{"topic_name":"interfaces","no_of_sub_topics":7,"folder_name":"interfaces","serial":13},"serial":2}},{"blogPK":{"topicName":"interfaces","subTopicName":"interfaces"},"content":"# Interface - part3## Interface Defines a New Type- An `interface` defines a new reference type,- You can use an `interface` type anywhere you can use a reference type,- All rules for a reference type variable apply to a variable of an `interface` type,- Let us see through an example:- Ex:  ```java  public interface Swimmable {      double DEFAULT_SPEED = 20;      void swim();  }  ```  ```java      public class Swimmer implements Swimmable{        private String name;        private final int id;        private Swimmable swimmable; // global variable        public Swimmer(String name, int id) {            this.name = name;            this.id = id;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getId() {            return id;        }        public Swimmable getSwimmable() {            Swimmable swimmable = this; // local variable            if(this.swimmable == null){                this.swimmable = swimmable;            }            return swimmable;        }        public void setSwimmable(Swimmable swimmable) { // parameter            this.swimmable = swimmable;        }        @Override        public void swim() {            System.out.println(\"Swimming...\");        }    }  ```  Calling like this:  ```java  private static void testReferenceType(){      Swimmer swimmer = new Swimmer(\"John\",1);      swimmer.swim(); // calling function  }  ```- A variable of an interface type refers to an object in memory whose class implements that interface,- Variable of interface type:  - Can be `null`,  - Can access constant field,  - Instant & static variable are initialized to `null` by default,  - Ex:    ```java    private static void testOperationOnVariable(){        Swimmable swimmable = null; // can be null        System.out.println(swimmable);          swimmable = new Swimmer(\"Tamim\",60);        double speed = swimmable.DEFAULT_SPEED; // can access constant field        System.out.println(speed); // 20.0              }    ```## Implementing an Interface- An `interface` defines a `specification` for objects about how they will communicate with other objects, i.e,- `interface` specifies how communication will be made between objects. i.e,- `interface` specifies method and `implementing-class` provides `implementation` for that method,- A `specification` is a set of statements,- `implementation` is the realization/execution of those statements,- When a class implements an `interface` is known as `implementing-class`,- `implementing-class` must provide implementations for all `abstract` methods of the interface if the class is not `abstract` itself,- `implementing-class` can also override `default` method of an `interface`,- Ex:  ```java    public interface Swimmable {        double DEFAULT_SPEED = 20;        void swim();    }  ```  implementing class definition is like  ```java  public class Swimmer implements Swimmable{      /*...*/      @Override      public void swim() { // must have to provide implementation          System.out.println(\"Swimming...\");      }    }  ```- As discussed earlier, variable of `interface` can hold object of `implementing-class` &- Assignment rules are similar to object assignment rules,- Ex:  ```java  private static void variableTest(){      Swimmable tuna = new Swimmer(\"Tuna\",22);      Swimmable dolphin = new Swimmer(\"Dolphin\",23);        Swimmer shark = new Swimmer(\"Shark\",45);        tuna = dolphin; // valid      dolphin = tuna; // valid        tuna = shark; // valid      dolphin = shark; // valid          shark = tuna; // invalid      shark = dolphin; // invalid    }  ```## Implementing Interface Methods- `implementing-class` must provide implementation for abstract method in `interface`,- Methods in an `interface` are implicitly public,- Implementing `throws` clause is optional in `implementing-class`. But,- You can't throw any exception that are not listed in interface,- Ex:  ```java  public class MyCheckedException extends Exception{        public MyCheckedException() {          // does nothing      }  }  ```  ```java  public interface Pressable {      int LONG_PRESS_DURATION = 200; // ms        void onPressed() throws IOException;      void onClicked();  }  ```  ```java  public class MyView implements Pressable{  //    @Override  //    public void onPressed() {} // ok. dropping exception        @Override      public void onPressed() throws IOException {}      //    @Override  //    public void onPressed() throws Exception {} // error. Can't throw new exception    //    @Override  //    public void onClicked() throws MyCheckedException{} // invalid. can't add checked exception        @Override      public void onClicked() {}  }  ```- General rule of thumb:  - If it makes sense to you, it's ok,  - If `overriding-method` in class relaxes the restrictions declared in the interface, then ok. Otherwise, not ok,  - `relaxes` means ignoring some exception like shown in above example,- Ignore all of these. Override method as it is defined in `interface`,## Implementing Multiple Interfaces- A class can implement multiple `interfaces`,- Must have to override all `abstract` methods of all `interfaces`,- Ex:  ```java  public interface Clickable {      default void onClicked(){...}  }  ```  ```java  public interface Pressable {      ...      void onPressed() throws IOException;      void onClicked();  }  ```  ```java  public class MyCustom implements Clickable,Pressable{            @Override      public void onPressed() throws IOException {}        @Override      public void onClicked() {          Clickable.super.onClicked(); // <----------(a)       }     }  ```  - In statement `(a)`, it is calling `onClicked()` method of `Clickable` interface,  - We have defined `onClicked()` in both in `Clickable` and `Pressable` interface,  - In `Clickable` interface, we have provided a default implementation of `onClicked()` method,  - We are calling the default implementation of `Clickable` interface when overriding in `MyCustom` class,  - You can provide your own implementation instead of calling the default method,- You can implement multiple interfaces in a class & those interface may contain some common method,- There is no problem if interfaces contain common method. Because we are providing our own implementation by overriding that method in `implementing-class`,- There is no such problem like `Diamond-problem` in implementing multiple interfaces,## Partially Implementing an Interface- A class can partially implement an `interface` iff it is declared as `abstract`,- Remember, `abstract-class` can have abstract method,- So, if a class implement few methods of an interface, then it will have to be `abstract`,- When a class inherit this `abstract-class`, it has to override all methods,- Simple concept. Don't be confused,- Ex: see by yourself,## The Supertype-Subtype Relationship- Implementing an `interface` to a class establishes a supertype-subtype relationship,- The class becomes a subtype of all the interfaces it implements,- All interfaces become a supertype of the class,- A subtype can be used wherever supertype can be used(`Substitution rule`),- Ex: See `MyCustom.java`,  ```java    public class MyCustom implements Clickable,Pressable{        @Override        public void onPressed() throws IOException {        }        @Override        public void onClicked() {            Clickable.super.onClicked();        }    }  ```  - Here `MyCustom` class is like subtype, and `Clickable`, `Pressable` are like supertype,  - Ex:  ```java  private static void requestClick(Clickable clickable){      clickable.onClicked();  }  ```  ```java  private static void subSuperTest(){      Clickable clickable = new MyCustom();      requestClick(clickable); // Clicked in clickable        MyCustom myCustom = new MyCustom();      requestClick(myCustom); // Clicked in clickable  }  ```  - Here parameter of `requestClick` method is of `Clickable` type. But,  - We can pass object of `MyCustom` class. Remember `Substitution rule`,<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part2/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part4/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"interfaces","subTopicName":"interfaces","topic":{"topic_name":"interfaces","no_of_sub_topics":7,"folder_name":"interfaces","serial":13},"serial":3}},{"blogPK":{"topicName":"interfaces","subTopicName":"interfaces"},"content":"# Interface - part4## Interface inheritance- Can inherit another one or multiple interfaces,- The inherited interfaces are known as `superinterfaces` and the interface inheriting them is known as `subinterface`,- An interface inherits the following members of its superinterfaces,    - Abstract and default methods,    - Constant fields,    - Nested types,- Does not inherit static methods from its superinterfaces,## Some interfaces used in below examples- `Singer` interface  ```java  interface Singer {      void sing();      void setRate(double rate);      double getRate();  }  ```- `Writter` interface,   ```java  interface Writer {      void write();      void setRate(double rate);      double getRate();  }  ```- `Player` interface,    ```java  interface Player {      void play();      void setRate(double rate);      default double getRate() {          return 300.0;      }  }  ```## Example-1: - See `TestInheritenceOne.java`,  Overriding is completely optional in `CharitySinger` since this is an interface,  ```java  interface CharitySinger extends Singer {      @Override      default void setRate(double rate) { // do nothing }        @Override      default double getRate() {          return 0.0;      }  }  ```  Overriding is must here since `MySinger` is a class,  ```java  static class MySinger implements CharitySinger {      @Override      public void sing() {          System.out.println(\"Singing free...\");      }  }  ```  Using like this:  ```java  public static void main(String[] args) {      CharitySinger singer = new MySinger();      singer.setRate(345);      System.out.println(singer.getRate()); // 0  }  ```- There is no problem in this example,## Example-2- It is possible that the same student is a `Singer` as well as a `Writer`,  ```java  interface SingerWriter extends Singer, Writer {      // No code  }  ```- `SingerWritter` interface inherits,   - 3 abstract methods from the `Singer` interface,  - 3 abstract methods from the `Writer` interface,  - Inherits methods `setRate()` and `getRate()` twice. One from `Writter` and one from `Writter`,  - This doesn't even cause any problem as both methods are abstract,- Example usage:  ```java  public class MyWriterSinger implements TestInheritanceOne.SingerWriter {        private double rate;        @Override      public void sing() {          System.out.println(\"Singing...\");      }        @Override      public void write() {          System.out.println(\"Writing...\");      }        @Override      public void setRate(double rate) {          this.rate = rate;      }        @Override      public double getRate() {          return rate;      }  }  ```- Calling like below:  ```java  SingerWriter singerWriter = new MyWriterSinger();  singerWriter.sing();  // Singing...  singerWriter.write(); // Writing...  ```- There is also no problem in this example,## Example-3- It is possible that the same student is a `Singer` as well as a `Player`,  ```java  interface SingerPlayer extends Singer, Player{   }  ```  - Above code generates this compile-time-error: `Player and Singer are incompatible; interface SingerPlayer inherits abstract and default for getRate() from types Player and Singer`,  - Error is because `getRate()` method,  - `getRate()` is abstract in `Writer` and default in `Player`. So,  - The compiler cannot decide which method to inherit.- This error will also occur if any or both of the method is `default`,- This error can be solved by overriding the method in `sub-interface`,- So, new implementation of `SinglePlayer` become: See `TestInheritenceOne.java`,  ```java  interface SingerPlayer extends Singer, Player{        //double getRate(); // ok    //    @Override  //    default double getRate() { // ok  //        // own implementation  //        return 0;  //    }        @Override      default double getRate(){          return Player.super.getRate();      }    }  ```- Overriding method can be `abstract` or `default`. It can also call parent implementation of the method. See uncommented method in above example,## Inheriting Conflicting ImplementationsWhen a class inherits a method with the same signature from multiple path(`class`, `interface` or `combination`), Java uses the `3` simple rules in order to resolve the conflict,- **The superclass always wins**, i.e.  - Method of superclass will be inherited,  - Method of interfaces will be ignored,  - Remember, multiple inheritance using class is not possible. So there can have maximum one parent-class,  - Ex: See `MultipleClick.java`, `Clickable.java` & `Test.java`,    ```java    public interface Clickable {          default void onClicked(){            System.out.println(\"Clicked in clickable\");        }    }    ```    ```java    class ClickDetector{        public void onClicked(){ // should be public            System.out.println(\"Calling from click detector\");        }    }      public class MultipleClick extends ClickDetector implements Clickable {      }    ```    Calling like this:    ```java    private static void conflictTest1(){        MultipleClick mc = new MultipleClick();        mc.onClicked(); //Calling from click detector    }    ```  - `interface` can't override `Object` class method. Why?     - Because `Object` class is the forefather of all classes,    - So, it doesn't make sense if an interface override such method,    - Such method will never be called since method of `Object` class will get precedence,    - That's why it is not allowed to override `Object` class method in interface,  - `default` method can't be final. Because,    - They are intended to be overridden in classes,    - Will generate compile time error if you do so,    - For ensuring backward-compatibility,    - If not resolved, then the **most specific superinterface wins**,  - Make a list of all choices of the method with the same signature that are available from different `superinterfaces`,  - Remove all methods from the list that have been overridden by others in the list,  - If you are left with only one choice, that is the method the class will inherit,  - In short, child class will get precedence,  - Ex:    ```java    public interface Clickable {      default void onClicked(){          System.out.println(\"Clicked in clickable\");      }    }    ```    ```java    public interface EventListener extends Clickable{      @Override      default void onClicked() {          System.out.println(\"click from event listener\");      }    }    ```    Calling like this:    ```java    private static void conflictTest2(){        new MyEvent().onClicked(); // click from event listener    }    ```- If still not resolved, **the class must override the conflicting method**,  - Nothing important here,  - Just override the method that has same signature and coming from two different interface,  - Ex: See `MyEvent2.java`,    ```java    public class MyEvent2 implements Clickable,Pressable{          @Override      public void onPressed() throws IOException {              }      @Override      public void onClicked() {          Clickable.super.onClicked();       }          }    ```    - After overriding `onClicked`, we are calling `onClicked` of `Clickable` interface,    - We can implement our own logic also,<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part3/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part5/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"interfaces","subTopicName":"interfaces","topic":{"topic_name":"interfaces","no_of_sub_topics":7,"folder_name":"interfaces","serial":13},"serial":4}},{"blogPK":{"topicName":"interfaces","subTopicName":"interfaces"},"content":"# Interface - part5## The `instanceof` Operator- To evaluate if a reference type variable refers to an object of a specific class or class implements a specific interface,- Structure:    ```java    <<referenceVariable>> instanceof <<referenceType>>    ```- Ex:  ```java  Giver giver = new Giver();  if(giver instanceof Object){      System.out.println(\"giver is an object\"); // executed  }  else{      System.out.println(\"giver is not an object\");  }  ```- If `left-hand` side of `instanceof` operator is `null` or refers to `null`, then it will return `false`,- So, if `var instanceof XYZ` returns `true`, then,  - `var` is not `null`,  - The cast `(XYZ)var` will always succeed, i.e.     - Class of `var` variable may be subclass of `XYZ` class. or,    - Class of `var` variable may implement `XYZ` interface,    - Above two can be done directly or indirectly,- Each expression has a compile-time and a runtime type in java,  - `instanceof` operator performs `compile-time` check as well as `runtime` check,- At compile-time, it checks if it is possible for its `left-hand` operand to point to an instance of its `right-hand` operand type,- Ex: See `InstanceOfTest.java`,  <img src=\"../files/instanceof_operator.jpg\" height=\"200px\">- For above structure:  - Ex-1:    ```java    Munificent john = new MunificentGiver();    System.out.println(john instanceof Munificent); // true    ```    - Because `MunificentGiver` implements `Munificent` interface,  - Ex-2:    ```java    Giver giver = new Giver();    System.out.println (giver instanceof Munificent); // false    ```    - Because `Giver` class doesn't implement `Munificent` interface,  - Ex-3:    ```java    Giver kim = new StingyGiver();    System.out.println(kim instanceof Munificent); // false    ```    - Because `StingyGiver` & `Giver`(parent of `StingyGiver`) class doesn't implement `Munificent` interface,  - Ex-4:    ```java    StingyGiver jim = new StingyGiver();    //System.out.println(jim instanceof Munificent);    ```    - `compile-time` error. Because    - Right side(`Munificent`) is not assignment compatible to left side(`StingyGiver`),    - How can the compiler be so sure about this possibility? It is easy,    - `StingyGiver` class is `final`, which means it cannot be `subclassed`,    - Variable `jim` whose `compile-time` type is `StingyGiver` can only refer to an object whose class is `StingyGiver`,    - The compiler also knows that the `StingyGiver` class and none of its ancestor classes implement the `Munificent` interface,    - With all these reasoning, the compiler determines that you have a logical error in your program & you need to fix it,## Marker Interfaces- When an interface has no members (declared or inherited), it is known as a marker interface.- Also called a `tag-interface`,- An interface can have members in two ways,  - by declaring its own members, or   - by inheriting members from its superinterfaces,- Why do we need it?  - Used to mark a class with a special meaning that can be used in a particular context,  - Class can be organized based on some category,- Ex:  ```java  interface Funny { // marker interface  }    class Human{      String name;      public Human(String name) { this.name = name; }  }    class Cat implements Funny {      String name;      public Cat(String name) { this.name = name; }  }    class Mouse implements Funny {      String name;      public Mouse(String name) { this.name = name; }  }  ```  ```java  private static void countFunny(ArrayList<Object> list){      int count = 0;      for (Object fun : list){          if(fun instanceof Funny) count++;      }      System.out.println(count+\" are funny\");  }  ```  Can be used like this:  ```java  Human john = new Human(\"John\");  Cat tom = new Cat(\"Tom\");  Mouse jerry = new Mouse(\"Jerry\");    ArrayList<Object> list = new ArrayList<>();  list.add(john);  list.add(tom);  list.add(jerry);  countFunny(list); // 2 are funny  ```- Java API has many marker interfaces. Ex: `java.lang.Cloneable`, `java.io.Serializable`, `java.rmi.Remote` etc,- Let's understand the `Clonable` interface:  - If your class implements the Cloneable interface,    - it means that you want to allow cloning of the objects of that class,    - Since `clone()` method has `protected` access in `Object` class. So     - For allow cloning You need to override the `clone()` method in your class,  - Suppose you have overridden `clone()` method in your class without implementing `Clonable` interface,    - Still the object of your class cannot be cloned until your class implements the `Cloneable` marker interface,  - You can see that, implementing `Cloneable` interface associates a meaning to the class that its object can be cloned,  - When the `clone()` method is invoked, Java performs a check     - If the class implements the `Cloneable` interface, then ok,    - Otherwise, it throws an exception at runtime,## Functional interface- Contains only one `abstract` method,- Ex: `StringListener.java`,  ```java  public interface StringListener {      void onDateSet(String date);  }  ```  - Can be used for passing date from a date-picker class to another class,## Comparing Objects`java.lang.Comparable` and `java.util.Comparator` are two commonly used interfaces for ordering objects,### Comparable- A class implements the `Comparable`, if objects of the class need to be compared for sorting purposes,- The ordering on the objects of a class imposed by `Comparable` interface is also called the class’s natural ordering,- Contains an `abstract` `compareTo()` method that takes one parameter,- The `compareTo()` method   - Doesn't handle `null` values,  - Returns zero(`0`), if the two objects are considered equal,  - Returns a negative integer(`< 0`), if the object is less than the parameter,  - Returns a positive integer(`> 0`), if the object is greater than the parameter,- `Comparable` interface is:  ```java  public interface Comparable<T> {     public int compareTo(T o);  }  ```- Ex:  ```java  public class Student implements Comparable<Student>{      private int roll;      private String name;      private String email;      private double height;      /*...*/      @Override      public int compareTo(Student o) {          // our own logic          return roll - o.roll; // sorting based on roll      }  }  ```  Using like this:  ```java  private static void comparableTest(){      // using Bard      Student studentOne1 = new Student(112, \"Rakib Hasan\", \"rakibhasan@gmail.com\", 1.75);      Student studentOne2 = new Student(23, \"Sadia Akter\", \"sadiaakter@gmail.com\", 1.65);      Student student3 = new Student(34, \"Ariful Islam\", \"arifulislam@gmail.com\", 1.80);      Student student4 = new Student(4, \"Tasnim Akhter\", \"tasnimakhter@gmail.com\", 1.55);      Student student5 = new Student(54, \"Rafi Ahmed\", \"rafi@gmail.com\", 1.70);      Student student6 = new Student(15, \"Sumaiya Khatun\", \"sumaiya@gmail.com\", 1.60);        List<Student> students = new ArrayList<>();      students.add(studentOne1); students.add(studentOne2); students.add(student3);      students.add(student4); students.add(student5); students.add(student6);        printRolls(students); // Rakib(112) Sadia(23) Ariful(34) Tasnim(4) Rafi(54) Sumaiya(15)      Collections.sort(students);      printRolls(students); // Tasnim(4) Sumaiya(15) Sadia(23) Ariful(34) Rafi(54) Rakib(112)  }  ```### Comparator- Used for specifying an ordering different from the ordering specified by the `Comparable` interface,- `Comparator` interface is:  ```java  public interface Comparator<T> {     int compare(T o1, T o2);     boolean equals(Object obj);     // Default and static methods are not shown here  }  ```  - `equals()` method is optional because it is inherited from `Object` class,  - `compare()` method takes `2` parameters and    - returns zero(`0`) if equal,    - returns a negative integer(`< 0`) if `1st` argument is less,    - returns a positive integer(`> 0`) if `2nd` argument is less,- Ex`(` Sort by `firstName` `)`:  ```java  private static void comparatorTest1(){      List<Student> list = getStudentList(); // create an list of 7 Students        class FirstNameComparator implements Comparator<Student>{          @Override          public int compare(Student o1, Student o2) {              return o1.getFirstName().compareTo(o2.getFirstName());          }      };        FirstNameComparator comparator = new FirstNameComparator();        printNames(list); // before sorting      // Rakib Hasan, Sadia Akter, Ariful Islam, Tasnim Akhter, Rafi Ahmed, Sumaiya Khatun, Sumaiya Akter,        Collections.sort(list,comparator);        printNames(list); // sorted by first name      // Ariful Islam, Rafi Ahmed, Rakib Hasan, Sadia Akter, Sumaiya Khatun, Sumaiya Akter, Tasnim Akhter,  }  ```- Ex`(` Sort by `firsName` then `lastName` `)`:  ```java  private static void comparatorMultiple(){        List<Student> list = getStudentList(); // create an list of 7 Students      List<Student> list2 = getStudentList(); // create an list of 7 Students        Comparator<Student> firstNameComparator = new Comparator<Student>() {          @Override          public int compare(Student o1, Student o2) {              return o1.getFirstName().compareTo(o2.getFirstName());          }      };        Comparator<Student> lastNameComparator = new Comparator<Student>() {          @Override          public int compare(Student o1, Student o2) {              return o1.getLastName().compareTo(o2.getLastName());          }      };        printNames(list);      // Rakib Hasan, Sadia Akter, Ariful Islam, Tasnim Akhter, Rafi Ahmed, Sumaiya Khatun, Sumaiya Akter,          list2.sort(firstNameComparator);      printNames(list2); // using firstName name. this is list2, not list      // Ariful Islam, Rafi Ahmed, Rakib Hasan, Sadia Akter, Sumaiya Khatun, Sumaiya Akter, Tasnim Akhter,        list.sort(firstNameComparator.thenComparing(lastNameComparator));      printNames(list);      // Ariful Islam, Rafi Ahmed, Rakib Hasan, Sadia Akter, Sumaiya Akter, Sumaiya Khatun, Tasnim Akhter,  }  ```- See `comparatorTestSimplified()` & `comparatorMultipleMinimized()` for minimized version of above 2 example,<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part4/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part6/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"interfaces","subTopicName":"interfaces","topic":{"topic_name":"interfaces","no_of_sub_topics":7,"folder_name":"interfaces","serial":13},"serial":5}},{"blogPK":{"topicName":"interfaces","subTopicName":"interfaces"},"content":"# Interface - part6## Polymorphism - One Object, Many Views- It is an ability of an object to provide its different views,- Interfaces let you create a polymorphic object,- Ex:    ```java    public interface Walkable {        void walk();    }    ```    ```java    public interface Swimmable {        void swim();    }    ```    ```java    public class Turtle implements Walkable,Swimmable{        private String name;        /*...*/          public void bite(){            System.out.println(name+\" is biting...\");        }        @Override        public void swim() {            System.out.println(name+\" is swimming...\");        }        @Override        public void walk() {            System.out.println(name+\" is walking...\");        }    }    ```    ```java    private static void testPolymorphic(){        Turtle turti = new Turtle(\"Turti\");            Swimmable swimmable = turti;        Walkable walkable = turti;        Object obj = turti;    }    ```  - `4` different views of the same `turti` object is shown in above `testPolymorphic` method. See below image:  <img src=\"files/polymorphic_views.jpg\" height=\"280px\">  - If we use `Walkable` view, then we can access `walk()` method on `Turtle` object,  - So, different views give different types of access to an object,- An object of a class can have the following views:  - A view that is **defined by its class** type  - Views that are **defined by all superclasses** (direct or indirect) of its class,  - Views that are **defined by all interfaces implements** by its class or superclasses(direct or indirect),  - In previous example `Turtle` class has `4` views:  - `1` from it own class,  - `1` from its superclass `Object`. Remember, `Object` class is superclass of all class,  - `2` from implementing two interfaces,- It may be useful if we want to give access to some particular method of a class,- One simple example: See `Test.java`,  ```java  private static void startWalking(Walkable walkable){      walkable.walk(); // Can't access other method      ...  }  ```  Calling like this  ```java  Turtle turti = new Turtle(\"Turti\");  startWalking(turti); // Turti is walking...  ```## Dynamic Binding and Interfaces- Java uses `dynamic-binding`when a method is invoked using a variable of an interface type,- See this example:  ```java  Walkable oogway = new Turtle(\"Oogway\");  oogway.walk();  ```  - The variable `oogway` has two types:    - a `compile-time` type which is `Walkable`,    - a `runtime-type` which is `Turtle`,  - While compiling `oogway.walk()`,     - The compiler verifies that the call is valid according to compile-type,  - While executing `oogway.walk()`, the runtime decides the implementation of the `walk()` method to invoke as follows:    - Gets info about the class of the object to which `oogway` is referring. Here it is `Turtle`,    - Then it looks for `walk()` method in that class. If not found, it will keep looking its ancestor class,    - If still not found, then it searches in all `super-interfaces` implemented by classes that were searched earlier. Now,      - If one specific `default` method is found, then execute it,      - If multiple `default` methods are found, then `IncompatibleClassChangeError` is thrown,      - If an abstract method is found, an `AbstractMethodError` is thrown,    - If still not found, then `NoSuchMethodError` is thrown,>> IF IT WERE TOO EASY, EVERYONE WOULD DO IT.<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part5/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part7/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"interfaces","subTopicName":"interfaces","topic":{"topic_name":"interfaces","no_of_sub_topics":7,"folder_name":"interfaces","serial":13},"serial":6}},{"blogPK":{"topicName":"interfaces","subTopicName":"interfaces"},"content":"# Interface - part7## A Real-World example using interface- Similar to real world problem,- We have a `Counter` class:   - That increments counter value after some seconds,  - Notify the values to the user,  - User can pause, resume, stop and start counter,  - If any invalid operation is requested, then it notifies user with a message,- We have a `MyApp` class:  - That initially starts the counter,  - Then keep interacting with user,  - Shows the current counter value to user after getting notified,  - Shows the error/message from `Counter` class,- For interacting between `Counter` and `MyApp` class we created `CounterListener` interface,- `CounterListener` interface  - Contains two methods:    - One for getting counter value,    - One for getting any error/message,- `CounterListener` interface:  ```java  public interface CounterListener {      void onTimeChanged(int currentTime);      void onMessageFound(String message);  }  ```- `Counter` class:    ```java    public class Counter {        private final int delayBetween;        private int maxCountValue;        private int currentValue = 1;        private boolean isRunning, isInPauseState;        private ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();        private final CounterListener listener;        public Counter(int delayBetween,CounterListener listener) {            this.delayBetween = delayBetween;            this.listener = listener;        }        public void startCounter(int maxCountValue){            if(isInPauseState){                listener.onMessageFound(\"Counter is in pause state\");                return;            }            if(isRunning) {                listener.onMessageFound(\"Counter already running\");                return;            }            currentValue = 0;            this.maxCountValue = maxCountValue;            startRunning();            isRunning = true;        }        public void stopCounter(){            if(!isRunning) {                listener.onMessageFound(\"Counter not running\");                return;            }            isRunning = false;            isInPauseState = false;            shutdownNow();            currentValue = 0;            listener.onMessageFound(\"Counter stopped\");        }        private void shutdownNow(){            executor.shutdownNow();            executor = Executors.newSingleThreadScheduledExecutor();        }        public void pause(){            if(!isRunning){                listener.onMessageFound(\"Counter not running\");                return;            }            if(isInPauseState){                listener.onMessageFound(\"Already in pause\");                return;            }            listener.onMessageFound(\"Counter paused\");            isInPauseState = true;            shutdownNow();        }        public void resume(){            if(!isRunning){                listener.onMessageFound(\"Counter not started\");                return;            }            if(!isInPauseState){                listener.onMessageFound(\"Counter is running...\");                return;            }            isInPauseState = false;            startRunning();        }        private void startRunning(){            if(currentValue >= maxCountValue) return;            isRunning = true;            executor.scheduleAtFixedRate(new Runnable() {                @Override                public void run() {                    currentValue++;                    listener.onTimeChanged(currentValue);                    if(currentValue >= maxCountValue) {                        listener.onMessageFound(\"Counting completed\");                        isRunning = false;                        shutdownNow();                    }                }            },0, delayBetween,TimeUnit.MILLISECONDS);        }    }    ```  - `MyApp` class:  ```java  public class MyApp {        public static void main(String[] args) {          startCounting(); // initially starting count      }        private static void startCounting(){          Counter counter = new Counter(1500, new CounterListener() {              @Override              public void onTimeChanged(int currentTime) {                  System.out.println(currentTime);              }                @Override              public void onMessageFound(String message) {                  System.out.println(message);              }          });            counter.startCounter(24);                    // below part interact with user          Scanner sc = new Scanner(System.in);          while (true){              int inp = sc.nextInt();              if(inp == 0) break;                if(inp == 1){                  counter.stopCounter();              }              else if(inp == 2){                  counter.startCounter(20);              }              else if(inp == 3){                  counter.pause();              }              else if(inp == 4){                  counter.resume();              }            }      }  }  ```- Above example can be achieved by using single class also. If you do so, your code will be complex and code readability will decrease,- **Write the whole example manually. Don't copy & paste. Then try to understand what the interface is doing.**### <p align=\"center\">Good luck with interface</p>>> \"If at First You Don't Succeed, Call It Version 1.0\" -- Khayri R.R. Woulfe<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part6/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/enum/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"interfaces","subTopicName":"interfaces","topic":{"topic_name":"interfaces","no_of_sub_topics":7,"folder_name":"interfaces","serial":13},"serial":7}},{"blogPK":{"topicName":"enum","subTopicName":"enum"},"content":"# Enum## Introduction- Lets you create an ordered list of constants as a type,- Mainly used for declaring constant,- Simple structure:    ```java    <access-modifier> enum <enum-type-name> {     // List of comma separated names of enum constants    }    ```- Ex:    ```java    public enum Gender {        MALE, FEMALE, OTHERS ; // these are enum constant    }    ```- It is a convention to name the enum constants in uppercase,- Java implements an enum type as a class,- The compiler does a lot of work for an enum type and generates code for it that is essentially a class,- Can't create object of enum type. But,- It can have constructor which is called by compiler only,- Can be used in `switch` statement,## Enum constant- All enum constants are objects of the same enum type,- In above `Gender` enum: `MALE`, `FEMALE`, `OTHERS` are enum constant,- Name is assigned to each enum constant,- Order number is assigned to each enum constant called `ordinal`,- The `ordinal` starts with zero & it is incremented by one for enum constant,    ```java    System.out.println(Gender.MALE.name()); // MALE    System.out.println(Gender.FEMALE.name()); // FEMALE    System.out.println(Gender.OTHERS.name()); // OTHERS        System.out.println(Gender.MALE.ordinal());   // 0    System.out.println(Gender.FEMALE.ordinal()); // 1    System.out.println(Gender.OTHERS.ordinal()); // 2    ```- Each enum constant can have different body. See `CommandList.java`, ## Enum again- An enum type is actually a class type. So, - You can declare pretty much everything inside an enum type body that you can declare inside a class body,- Can't add a public or protected constructor to an enum type. If you do so, they will be automatically converted to private during compilation,- Ex: See `MyWeekDay.java`:    ```java    public enum MyWeekDay {        SATURDAY(true),SUNDAY(false),MONDAY(false),        TUESDAY(false), WEDNESDAY(false),THURSDAY(false), FRIDAY(false);            // see above constant carefully. They all are objects.         // We are actually using constructor of this class to create constant.            private final boolean isHoliday;        private MyWeekDay(boolean isHoliday){            this.isHoliday = isHoliday;        }            public boolean isHoliday() {            return isHoliday;        }        }    ```- Example usage: See `Test.java`:    ```java    private static int countWorkingDays(List<MyWeekDay> days){        int counter = 0;            for(MyWeekDay day : days){            if(day.isHoliday()) continue;                counter++;        }            return counter;    }    ```    Calling is like:    ```java    ArrayList<MyWeekDay> days = new ArrayList<>();    days.add(SATURDAY);    days.add(MONDAY);    days.add(THURSDAY);        System.out.println(countWorkingDays(days)); // 2    ```## Comparing Two Enum Constants- Two enum constant can be compared in 3 ways:  - `compareTo()` method     - Returns difference in their `ordinal`,    - Must be of same type,  - `equals()` method    - An enum constant is equal only to itself,    - For comparing two enum constants of different types,  - `==` operator,    - Must be of same type,- Ex:    ```java    Gender gender1 = Gender.MALE;    Gender gender2 = Gender.FEMALE;    Gender gender3 = Gender.MALE;        MyWeekDay day1 = SATURDAY;    MyWeekDay day2 = MONDAY;    MyWeekDay day3 = MONDAY;        // compareTo    System.out.println(gender1.compareTo(gender2)); // -1    System.out.println(gender1.compareTo(gender3)); // 0        // equals    System.out.println(gender1.equals(day1)); // false    System.out.println(day1.equals(day2)); // false    System.out.println(day2.equals(day2)); // true        // ==    System.out.println(gender1 == gender3); // true    System.out.println(day1 == day3); // false    ``` ## Nested enum type- You can declare a nested enum type inside a class, an interface, or another enum type, - Nested enum types are implicitly static,    ```java    public class Test {        ...        //nested enum        public enum NestedEnum{            MY_VALUE1,MY_VALUE2;        }        ...    }    ```## Implementing interface- An enum type may implement interfaces,- An enum type is never inherited by another enum type. So,- You must provide implementation for all abstract methods in that interface,- See `CommandList.java`, `Executable.java`:    ```java    public interface Executable {        void execute();    }    ```    ```java    public enum CommandList implements Executable{        RUN{            @Override            public void doNothing() { }        },        JUMP{            @Override            public void doNothing() { }        };            @Override        public void execute() {            if(this.equals(RUN)){                System.out.println(\"Running\");            }            else if(this.equals(JUMP)){                System.out.println(\"Jumping\");            }        }        public abstract void doNothing();    }    ```java    Calling is like:    ```    RUN.execute(); // Running    JUMP.execute(); // Jumping    ```## Abstract method in enum- Enum can have abstract method. But,- You must have to override it in every constant,- See `doNothing()` in `CommandList.java` above;## Reverse Lookup for Enum Constants- We can get enum constant by `name` of `ordinal`,    ```java    System.out.println(MyWeekDay.valueOf(\"SATURDAY\")); // SATURDAY    System.out.println(MyWeekDay.values()[0]); // SATURDAY    ```## Range of Enum Constants- Can find all enum constant by performing search,- Abstract class `EnumSet` is used for this,- Ex:    ```java    EnumSet<MyWeekDay> days = EnumSet.allOf(MyWeekDay.class);    printArray(days.toArray()); // SATURDAY SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY        EnumSet<MyWeekDay> workingDays = EnumSet.range(SUNDAY,THURSDAY);    printArray(workingDays.toArray()); // SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY        EnumSet<MyWeekDay> holidays = EnumSet.complementOf(workingDays);    printArray(holidays.toArray()); // SATURDAY FRIDAY     ``` >> ENUM IS MAINLY USED FOR DECLARING CONSTANT & IT SHOULD BE ENOUGH FOR YOU<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/interfaces/part7/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/java17/part1/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"enum","subTopicName":"enum","topic":{"topic_name":"enum","no_of_sub_topics":1,"folder_name":"enum","serial":14},"serial":0}},{"blogPK":{"topicName":"java17","subTopicName":"java17"},"content":"# Main changes from java-8 to java-17## New `var` keyword- A new `var` keyword was added that allows local variables to be declared in a more concise manner,- Ex:    ```java    var name = new String(\"hello\");    System.out.println(name); // hello        var student = new Student(121,\"Doniel\",5.9);    System.out.println(student.getName()); // Doniel    System.out.println(student.getHeight()); // 5.9    ```## Extended switch expressions- Cleaner and less error-prone syntax,- `case` label followed by `->` followed by one of the following:  - `An expression`, including but not limited to a constant value,  - A `throw` statement,  - A `code block` using opening and closing curly brackets- Ex:    ```java    int i = 20;    switch (i){        case 10 -> {            System.out.println(10);            System.out.println(\"10\");        }        case 20-> System.out.println(20); // executed        default-> System.out.println(\"Other\");    }        i = 40;    String message = switch (i){        case 10 -> \"10\";        case 20 -> \"20\";        case 30 -> throw new RuntimeException(\"idk\");        case 40 ->{            System.out.println(\"40\"); // executed            yield \"like return\";        }        default -> \"none\";    };        System.out.println(message); // like return    ```## `instanceof` pattern matching- Till now, we do like this  ```java  Student student = new PartTimeStudent(12,\"Imran\",5.5,12);  PartTimeStudent partTimeStudent;  if(student instanceof PartTimeStudent){    partTimeStudent = (PartTimeStudent)student;   }  ```- Above can be simplified like this:  ```java  Student student = new PartTimeStudent(12,\"Imran\",5.5,12);            if(student instanceof PartTimeStudent partTimeStudent){    // partTimeStudent  }  ```## Sealed Classes- Another way to `disable inheritance` introduced in `Java 17`,- Allows you to define a class and exactly `what classes can subclass it`,- Subclass of Sealed class must define their status: `final`, `sealed`, or `non-sealed`,- Ex(Sealed class):  ```java  public abstract sealed class Security permits Lock, Pin, Password { }  ```  Inheriting `sealed-class`:  ```java  final class Lock extends Security{ } // no class can inherit it  non-sealed class Pin extends Security{ } // any class can inherit it  sealed class Password extends Security permits MyPassword{ } // same as sealed  ```  Inhering `subclass` of `sealed-class`,  ```java  final class MyPassword extends Password{} // inherited above sealed class    class MyPin extends Pin{} // Since Pin class can be inherited by any class  ```  ## Multiline Strings- Is done via `TextBlocks`,- A `text block` must start  - with `three quotation marks`, then  - `a new line`, then   - your text as you write normally,- Ex(Earlier way):  ```java  String formattedTextEarlier = \"This is first line.\\n\"+          \"THis is second line.\\n\"+          \"Continue like that\";  System.out.println(formattedTextEarlier);  ```  New way:  ```java  String formattedText = \"\"\"          This is first line.          THis is second line.          Continue like that\"\"\";  System.out.println(formattedText);  ```  Output:  ```text  This is first line.  THis is second line.  Continue like that  ```  Below one is `invalid` since uou can't write just after first `\"\"\"`,  ```java  String formattedText2 = \"\"\"This is first line.          THis is second line.          Continue like that\"\"\";  ```## Record- Previous way:  ```java  public class Person {      final String name;      final int age;        public Person(String name, int age) {          this.name = name;          this.age = age;      }        public String getName() {          return name;      }        public int getAge() {          return age;      }  }  ```  New way:  ```java  public record PersonRecord(String name, int age) { }  ```  Using like this:  ```java  Person student = new Person(\"Saeed\",2345);    PersonRecord record = new PersonRecord(\"Saeed\",2345);    System.out.println(student.getName() + \" - \" + record.name()); // Saeed - Saeed  System.out.println(student.getAge() + \" - \" + record.age()); // 2345 - 2345  ```<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/enum/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/qna/\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"java17","subTopicName":"java17","topic":{"topic_name":"java17","no_of_sub_topics":1,"folder_name":"java17","serial":15},"serial":1}},{"blogPK":{"topicName":"qna","subTopicName":"qna"},"content":"## --- Java Stack Memory vs Heap Memory ---#### Stack Memory - Holds the values of the primitive type variables. (int, float, double, char, boolean, etc.),- Reference variables are stored in the Stack.#### Heap Memory - Stores the non-primitive objects,- String Constant Pool also resides in the Heap Memory.<div><img src=\"./images/stack_and_heap.jpeg\" alt=\"Stack and Heap\" height=\"300px\"></div>Image Source: Scalar<hr>## --- Find output of this program ---```javaclass A{    public void m1(){        System.out.println(\"A.m1()\");    }    public void m2(){ // <---------------------------        System.out.println(\"A.m2()\");    }}``````javaclass B extends A{    public void m2(){        System.out.println(\"B.m2()\");    }}``````javaclass OverridingTest{    public static void main(String[] args) {        A a = new B();        a.m1(); // A.m1()        a.m2(); // B.m2() // <--------------    }}```- If `class-A` doesn't contain method `m2()`, then compile time error. But if `class-A` contains method `m2()`, then `m2()` of `class-B` will be called. Because variable `a` is referring to object of `class-B`,- But why:- **The error occurred because of Java's static type checking,**- The class of the reference variable determines which instance methods can be called on it and since `class-A` doesn't have method `m2()`, the compiler will complain,- But when we are adding `m2()` in `class-A`, compiler error will be gone. Now in runtime it will call `m2()` of `class-B` since variable `a` is referring to an object of `class-B` due to polymorphism rule.<!-- bottom_nav_bar_1243 --><div align=\"center\"><a href=\"https://github.com/abusaeed2433/JavaInREADME/tree/main/java17/part1/\">    <img src=\"https://img.shields.io/badge/◀%20Previous-blue?style=for-the-badge\" alt=\"Previous\"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"None\">    <img src=\"https://img.shields.io/badge/Next%20▶-blue?style=for-the-badge\" alt=\"Next\"></a></div><!-- bottom_nav_bar_1243 -->    ","subTopic":{"topicName":"qna","subTopicName":"qna","topic":{"topic_name":"qna","no_of_sub_topics":1,"folder_name":"qna","serial":16},"serial":0}}]